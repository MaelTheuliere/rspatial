[["index.html", "Les données spatiales avec R Introduction", " Les données spatiales avec R Maël THEULIERE 2021-01-15 Introduction Ce support est le support du module du même nom du master Mégadonnées et Analyse sociale du CNAM de Loire-Atlantique. Lobjectif de ce cours est de présenter les éléments de manipulation des données spatiales à partir de R. Nous verrons ainsi : Ce que sont les données spatiales Comment lire des données spatiales ? Comment manipuler les données spatiales ? Comment visualiser les données spatiales ? "],["bien-commencer.html", "Chapitre 1 Bien commencer 1.1 Créer un projet sous Rstudio pour vous permettre de recenser vos travaux. 1.2 Désactiver les options de sauvegarde automatique de Rstudio 1.3 Intégrer vos données 1.4 Créer votre arborescence de projet 1.5 Activer les packages nécessaires 1.6 Bien structurer ses projets data", " Chapitre 1 Bien commencer 1.1 Créer un projet sous Rstudio pour vous permettre de recenser vos travaux. Pourquoi travailler avec les projets Rstudio plutôt que les scripts R ? Cela permet la portabilité : le répertoire de travail par défaut dun projet est le répertoire où est ce projet. Si vous transmettez celui-ci à un collègue, le fait de lancer un programme ne dépend pas de larborescence de votre machine. Fini les setwd(\"chemin/qui/marche/uniquement/sur/mon/poste\") ! Toujours sur la portabilité, un projet peut être utilisé avec un package comme packrat ou renv qui vont vous permettre dinternaliser au sein du projet lensemble des packages dont vous aurez besoin dans la version avec laquelle vous lavez utilisé. Cela permet donc à votre collègue à qui vous passez votre projet de ne pas avoir à les installer dans la même version, et si vous mettez à jour votre environnement R, votre projet restera toujours avec les versions des packages avec lesquelles vous lavez fait tourner à lépoque. Cela évite davoir à subir les effets dune mise à jour dun package qui casserait votre code. Packrat est intégré à Rstudio. Pour activer packrat sur un projet, aller dans Tools/Project Options-&gt;Packrat En savoir plus sur Packrat renv est plus récent que Packrat, il nest pas encore intégré à Rstudio mais apporte des améliorations subsentielles par rapport à son prédécesseur. En savoir plus sur renv Cela permet de se forcer à travailler en mode projet : on intègre à un seul endroit tous ce qui est lié à ce projet : données brutes, données retravaillées, scripts, illustrations, documentations, publications et donc y compris packages avec packrat ou renv. On peut travailler sur plusieurs projets en même temps, Rstudio ouvre alors autant de sessions que de projets. Les projets Rstudio intègrent une interface avec les outils de gestion de version git et svn. Cela veut dire que vous pouvez versionniser votre projet et lhéberger simplement comme répertoire sur des plateformes de gestion de code telle que github ou gitlab. Pour créer un projet : Cliquez sur Project en haut à droite puis New Project. Cliquez sur New Directory. 1.2 Désactiver les options de sauvegarde automatique de Rstudio Votre code doit être reproductible depuis vos données en entrée vers votre résultat. Pour cela, il est fortement déconseillé de sauvegarder quoique ce soit dans le fichier .RData de sauvegarde par défaut. Pour cela, aller dans Tools-&gt;Global Options et ensuite conformez vous à ceci 1.3 Intégrer vos données Une bonne pratique est de créer un sous répertoire /extdata pour stocker les données sur lesquelles vous aurez à travailler et un dossier /data pour stocker les données après préparation. Vous pouvez le faire de lexplorateur de fichier de votre système dexploitation ou directement à partir de lexplorateur de fichier de RStudio. Si par la suite vous souhaitez avoir des exemples de bonnes pratiques sur comment structurer vos données, vous pouvez vous référer au chapitre data du livre dHadley Wickham sur la construction de package R (tout package R étant aussi un projet !) 1.4 Créer votre arborescence de projet Créer un répertoire /src où vous mettrez vos scripts R. Créer un répertoire /figures où vous mettrez vos illustrations issues de R. 1.5 Activer les packages nécessaires Commencer par rajouter un script dans le répertoire /src à votre projet qui commencera par : activer lensemble des packages nécessaires charger les données dont vous aurez besoin. 1.6 Bien structurer ses projets data Plusieurs documents peuvent vous inspirer sur la structuration de vos projets data par la suite. En voici quelques uns : https://github.com/pavopax/new-project-template https://nicercode.github.io/blog/2013-04-05-projects/ https://www.inwt-statistics.com/read-blog/a-meaningful-file-structure-for-r-projects.html http://projecttemplate.net/architecture.html A partir du moment où quelques grands principes sont respectés (un répertoire pour les données brutes en lecture seule par exemple), le reste est surtout une question dattirance plus forte pour lune ou lautre solution. Limportant est de vous tenir ensuite à garder toujours la même structure dans vos projets afin de vous y retrouver plus simplement. "],["la-modélisation-des-données-spatiales.html", "Chapitre 2 La modélisation des données spatiales 2.1 Les données vecteur 2.2 Les données raster 2.3 La structuration des données géographiques avec R", " Chapitre 2 La modélisation des données spatiales Dans ce chapitre,nous allons développer une brève introduction à la modélisation des données géographiques. 2.1 Les données vecteur Les données vecteur sont une modélisation du monde utilisant des points, des lignes et des polygones. Les données vecteur sont en général plus utilisées en sciences sociales, les territoires créés par lhomme ayant la plupart du temps des frontières discrètes. Derrière les données vecteur, se trouvent des points. Les points peuvent représenter des caractéristiques autonomes (comme lemplacement de létablissement dune entreprise), ou peuvent être reliés entre eux pour former des géométries plus complexes telles que des lignes (comme des cours deau) et des polygones (les frontières dun pays). Ces points sont localisés à travers un système de référence de coordonnées (CRS). La plupart des géométries ponctuelles ne contiennent que deux dimensions (les CRS à trois dimensions contiennent une valeur supplémentaire z pour la hauteur du point en référence au niveau de la mer). 2.2 Les données raster Les données raster modélisent la surface du globe à laide de celulles de taille identique. Les données raster sont en générale plus utilisées dans les science environnementales, du fait de la fiabilité des données de télédétections disponibles. 2.3 La structuration des données géographiques avec R 2.3.1 sf pour les données vecteur Le packages sf permet de gérer les données vecteur. Avant sf existait le package sp que vous pourrez rencontrer suivant les packages plus spécifiques que vous utiliserez ou en cherchant de laide. Les avantages de sf sont multiples : Standardisation : sf utilise le modèle de données simple feature1 qui est un standard largement utilisé dans le domaine de la géomatique. Simplification du modèle de données. Les données spatiales sont un dataframe avec une variable spécifique renseignant la géométrie en créant un type ad hoc en plus des types standard (numériques, entiers, booléens, caractères, facteur). Ce dataframe aura une classe spécifique qui lui sera associée (classe sf). La syntaxe des fonctions est unifiée et simplifiée selon le manifeste du tidyverse2. Intégration. Les verbes du tidyverse sont compatibles avec les données spatiales de classe sf et vont parfois agir avec des propriétés spécifiques sur les données géométriques. On peut également utiliser le pipe dans le processus de travail. Perfomance : meilleure performance dans la lecture et lécrite des données. Voir un benchmark sur la page du package sf 2.3.2 raster et stars pour les données raster Les packages raster et stars permettent de gérer les données raster. raster est aussi un package historique amené à être supplanté par stars. stars est dune part plus vaste que raster, car il vise à gérer les données spatio-temporelle plus largement. stars est intégré à sf et au tidyverse On se limitera pour la suite du cours aux données vecteur et donc à sf. https://en.wikipedia.org/wiki/Simple_Features https://tidyverse.tidyverse.org/articles/manifesto.html "],["les-systèmes-de-coordonnées-de-référence.html", "Chapitre 3 Les Systèmes de Coordonnées de Référence 3.1 Le système géodésique ou datum 3.2 Les coordonnées 3.3 Code EPSG", " Chapitre 3 Les Systèmes de Coordonnées de Référence Les données spatiales vises à modéliser la terre. La terre est un objet dont la mesure a une longue histoire, quon a pensé plate, cylindrique, ronde, ellipsoïde. Maintenant, on sait que la terre a cette forme là : THE REAL SHAPE OF PLANET EARTH - 3D Animation HD from eLearn.Punjab on Vimeo. Les systèmes de coordonnées de référence vont permettre de se repérer sur la surface de la terre. 3.1 Le système géodésique ou datum Pour modéliser la surface terrestre, on va définir un géoïde, qui est la surface théorique de la pesanteur. Ce géoïde est proche dun ellipsoïde, cest à dire une surface obtenue en faisant tourner une ellipse sur son axe. La terre est en effet compressée : le rayon à léquateur est 11,5 km plus long que le rayon polaire (Maling 1992). On va donc pouvoir approximer ce géoïde par un ellipsoïde. Un point quelconque est repéré par rapport à lellipsoïde en utilisant un système de coordonnées sphériques : longitude, latitude, altitude. Le datum ou système géodésique va correspondre aux paramètre de forme de lellipsoïde et de positionnement sur celle ci. On va distinguer deux types de datum : les datum locaux et les datum globaux. Historiquement nexistait que des datum locaux, cest à dire qui définissait une ellipse optimale pour correspondre à une partie déterminée de la surface de la terre. Cette contrainte était liée à la façon de définir le géoïde : avant les techniques spatiales, on utilisait des mesures de triangulation à partir dun point défini par mesure astronomique. Depuis lavènement des techniques spatiales, on est capable de définir un datum global grâce aux mesures satellitaires. Le système mondial de référence est aujourdhui le WGS 84, associé au GPS. Il y a donc aujourdhui beaucoup de datum, un pour la plupart des pays, qui maximise la modélisation de lellipsoïde sur leur territoire, et des datums globaux. 3.2 Les coordonnées Pour se repérer sur terre, on va utiliser un système géodésique sur lequel on va se positionner avec des coordonnées. On distingue deux types de coordonnées : 3.2.1 Coordonnées géographiques Les systèmes de coordonnées géographiques identifient tout lieux sur la surface de la terre en utilisant deux paramètres, la longitude et la lattitude : La Longitude est la localisation sur la direction Est-Ouest. Elle est définie par langle par rapport à un méridien. La Latitude définie la localisation sur la direction Nord-Sud. Elle est définie par langle avec léquateur. Dans un système de coordonnées géographiques, les lieux sont donc identifiés par des angles et non des mètres. 3.2.2 Coordonnées en projection Les systèmes de coordonnées projetés se basent sur une modélisation de la terre plane (donc projetée sur un plan) et un système de coordonnés cartésien pour définir un point sur ce plan à partir dune origine, dun axe x, dun axe y et dune unité de mesure (comme le mètre). Tous les systèmes de coordonnées projetés se basent sur un système de coordonnées géographiques et sur une projection spatiale des données de lellipse en 3D sur un plan. Cet exercice ne peut se faire sans distorsion. Les propriétés de la surface de la terre comme laire, la direction, la distance, la forme ne peuvent être toutes conservées. En général un système de coordonnées projetés ne permet de préserver quune ou deux de ces propriétés. On classifie dailleurs ces projections selon les propriétés conservées : conformes (conservent les angles) équivalentes (conservent les surfaces) aphylactique (peut être équidistante, cest-à-dire conserver les distances sur les méridiens) On distingue également les projection en fonction de leur mode de projection. Il y a trois principaux groupes de projections : Conique : la terre est projetée sur un cone reposant sur une ou deux tangentes. Les distorsions sont faibles sur la ligne de tangente et augmentent ensuite avec la distance à celle-ci. Cest ainsi le type de projection le mieux adapté pour des cartes réalisées sur des latitudes médianes. Cylindrique : ces projections projettent la surface de la terre sur un cylindre. Souvent utilisées pour cartographier la terre entière. Plane : projection du globe sur une surface plane tangeante en un point ou sur une ligne. Souvent utilisée pour les régions polaires. 3.2.3 Exemple de projections 3.2.3.1 Equal Earth Le but de la projection Equal-Earth est de représenter la Terre avec toutes ses régions à part égale. Equal Earth est une projection pseudo-cylindrique ressemblant à celle de Robinson qui évoque comme elle la rotondité de la Terre. Mais à la différence de cette dernière, elle préserve les surfaces. http://cartonumerique.blogspot.com/2018/11/la-projection-equal-earth.html 3.3 Code EPSG LEPSG (European Petroleum Survey Group), un groupe créé en 1985, a défini une liste des systèmes de coordonnées géoréférencées et leur a associé des codes pour les identifier. Le groupe est devenu en 2005 le Comité de topographie et de positionnement de lAssociation internationale des producteurs de pétrole et de gaz (OGP). La liste peut être trouvée sur ce site. Un système géodésique peut recevoir plusieurs codes EPSG selon son utilisation : 2D ou 3D par exemple. "],["lire-et-écrire-des-données-spatiales-avec-r.html", "Chapitre 4 Lire et écrire des données spatiales avec R 4.1 Lire des fichiers plats 4.2 Ecrire des fichiers plats 4.3 Lire/ecrire des données spatiales sur PostGIS 4.4 Convertir un dataframe", " Chapitre 4 Lire et écrire des données spatiales avec R Dans ce chapitre, nous allons utiliser les packages suivants : library(sf) library(DT) library(tidyverse) library(RPostgres) Le package sf sappuie sur GDAL (Geospatial Data Abstraction Library) pour lire et écrire les données spatiales. GDAL est une librairie permettant de lire et décrire des données vecteur et raster de nimporte quel format de fichier ou base de données. Les fonctions de lecture et décriture de sf sappellent st_read() et st_write(). Pour lire des données spatiales,s st_read() a besoin : dune source de donnée : un fichier, un répertoire, une base de données ; dun layer: une table de données spatiale spécifique du du fichier, répertoire, ou de la base de données ; On peut avoir besoin de rajouter des options spécifiques au format de la source. Par exemple, sur des données en csv, il faut pouvoir spécifier la composante spatiale des données. 4.1 Lire des fichiers plats st_read() permet de lire des données spatiales disponibles en fichier plat. Le format de fichier plat le plus populaire en géomatique est ESRI Shapefile. Ce format, en plus de ne pas être un format ouvert, a des limites bien documentées3. Avec lavènement du web, le format GeoJSON se développe beaucoup, bien quil soit aussi limité. Le format considéré comme le plus prometeur est le format OGC GeoPackage promu par lOpen Geospatial Consortium4. Mais la liste des formats lisibles par sf est bien plus vaste. Pour lobtenir, on peut utiliser st_drivers() DT::datatable(st_drivers() %&gt;% arrange(name)) Exemple de lecture dune donnée au format GeoPackage: les données sur la Leucémie à New York disponibles dans le package spData5. geo_fichier &lt;- system.file(&quot;shapes/NY8_bna_utm18.gpkg&quot;, package = &quot;spData&quot;) NY_leukemia &lt;- st_read(dsn = geo_fichier) Reading layer `sf_bna2_utm18&#39; from data source `C:\\Users\\mael.theuliere\\Documents\\R\\win-library\\4.0\\spData\\shapes\\NY8_bna_utm18.gpkg&#39; using driver `GPKG&#39; Simple feature collection with 281 features and 12 fields geometry type: MULTIPOLYGON dimension: XY bbox: xmin: 357628 ymin: 4649538 xmax: 480360.3 ymax: 4808317 projected CRS: UTM Zone 18, Northern Hemisphere 4.2 Ecrire des fichiers plats Ecrire des fichiers plats va se faire avec la fonction st_write(). st_write(obj = NY_leukemia, dsn = &quot;extdata/NY_leukemia.gpkg&quot;) Notez que si vous cherchez à exporter une nouvelle fois ce fichier, vous aurez un message derreur. Pour pouvoir écraser ce fichier, vous avez deux options : Utiliser le paramètre layer_option qui vous permet dinclure des options propres au driver utilisé. st_write( obj = NY_leukemia, dsn = &quot;extdata/NY_leukemia.gpkg&quot;, layer_options = &quot;OVERWRITE=YES&quot; ) Utiliser le paramètre delete_layer = T de st_write() qui vous permet décraser les layer avant sauvegarde (paramètre qui ne dépend pas du driver utilisé). st_write( obj = NY_leukemia, dsn = &quot;extdata/NY_leukemia.gpkg&quot;, delete_layer = T ) 4.3 Lire/ecrire des données spatiales sur PostGIS PostGIS, cest lextension géomatique de PostgreSQL permettant de stocker des données géo sur un serveur de données et de les manipuler. R va vous permettre de vous connecter simplement à une base PostGIS, pour cela vous aurez besoin du package DBI (package permettant de sinterfacer à des bases de données) et du package RPostgres (interface à PostgreSQL) Rstudio a développé tout un site sur les interactions entre les bases de données et R, vous pouvez le trouver à ladresse suivante : db.rstudio.com. Rstudio possède même depuis la version 1.1 un onglet de connexion vous permetttant de visualiser vos connexions aux bases. Pour se connecter à une base, on va définir un driver (à quelle type de base on veut se connecter) et un connecteur (les informations de connexion). drv &lt;- dbDriver(&quot;Postgres&quot;) con &lt;- dbConnect(drv, dbname = &quot;nom_de_ma_db&quot;, host = &quot;adresse_ip_du_serveur&quot;, port = numero_du_port, user = &quot;nom_utilisateur&quot;, password = &quot;mot_de_passe_super_secret&quot; ) Pour lire des données sur le serveur, on va utiliser encore la fonction st_read() en lui définissant 2 paramètres : le connecteur et la requête que lon veut réaliser. ma_table &lt;- st_read(con, query = &quot;SELECT * FROM le_schema.ma_table&quot;) Lavantage ici est que vous pouvez faire travailler le serveur directement sans avoir à faire travailler votre poste de travail. Vous pouvez très bien dans cette requête sql réaliser quelques filtres, sélections et aggrégations. Celles-ci seront alors réalisées par le serveur posgreSQL et non R qui ne récupèrera que le résultat. Vous pouvez écrire vos données ensuite de la même façon avec st_write() st_write(ma_table, dsn = con, layer = ID(schema = &quot;schema&quot;, table = &quot;ma_table&quot;) ) 4.4 Convertir un dataframe Une autre façon dobtenir un spatial dataframe est de convertir un objet existant en objet sf. Par exemple, partir dun dataframe sur lequel on va définir à la fois la ou les colonnes contenant la dimension géographique et le crs de référence. Ou encore convertir un objet de type sp en objet de type sf. Pour cela, la fonction st_as_sf() permet de convertir un objet en objet sf en définissant la composante spatiale. La fonction st_set_crs() permet de définir le crs de notre objet. Exemple, nous allons lire les coordonnées géographiques des préfectures de région. prefectures &lt;- read_csv2(&quot;extdata/prefecture.csv&quot;) prefectures_geo &lt;- st_as_sf(prefectures, coords = c(&quot;x&quot;, &quot;y&quot;)) %&gt;% st_set_crs(2154) voir http://switchfromshapefile.org/ https://www.geopackage.org/ Issues de Waller and Gotway (2004) Applied Spatial Statistics for Public Health Data. "],["les-opérations-sur-données-attributaires.html", "Chapitre 5 Les opérations sur données attributaires", " Chapitre 5 Les opérations sur données attributaires Dans ce chapitre, nous allons utiliser les packages suivants : library(sf) library(tidyverse) library(mapview) Nous utiliserons les contours des territoires de la France métropolitaine issus de Admin Express. load(&quot;data/admin_express.RData&quot;) Prenons la table des départements, cette table est un spatial dataframe. class(departements_geo) [1] &quot;sf&quot; &quot;data.frame&quot; On peut utiliser mapview() pour voir ce jeu de données. mapview(departements_geo, zcol = &quot;NOM_DEP&quot;, legend = F) Comme évoqué dans la partie 1, on peut tout à fait appliquer sur un spatial dataframe les verbes du tidyverse comme sur un dataframe, notamment utiliser les verbes de dplyr. Nous pouvons à partir de cette table filtrer les départements dune certaine région. departements_geo %&gt;% filter(INSEE_REG == 52) # A tibble: 5 x 8 ID NOM_DEP NOM_DEP_M INSEE_DEP INSEE_REG CHF_DEP geometry AREA &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [m]&gt; [m^2] 1 DEP000000~ Loire-Atl~ LOIRE ATL~ 44 52 44109 (((276740.4 6716295, 276731.6 6716306,~ 6993453~ 2 DEP000000~ Maine-et-~ MAINE ET ~ 49 52 49007 (((419760.9 6744627, 419764.4 6744595,~ 7160811~ 3 DEP000000~ Mayenne MAYENNE 53 52 53130 (((396987 6794449, 396962.3 6794493, 3~ 5207960~ 4 DEP000000~ Sarthe SARTHE 72 52 72181 (((463296.2 6791791, 463173 6791927, 4~ 6238065~ 5 DEP000000~ Vendée VENDEE 85 52 85191 (((293495.7 6674024, 293493.1 6674012,~ 6758559~ Nous pouvons ne sélectionner que quelques variables departements_geo %&gt;% select(INSEE_DEP) %&gt;% glimpse() Rows: 96 Columns: 2 $ INSEE_DEP &lt;chr&gt; &quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;... $ geometry &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((838383.2 65..., MULTIPOLYGON (((708719 6956..., MULTIPOLYGO... A noter que par défaut, un spatial dataframe gardera toujours la géométrie. Nous pouvons agréger nos données. regions &lt;- departements_geo %&gt;% group_by(INSEE_REG) %&gt;% summarise(AREA = sum(AREA)) glimpse(regions) Rows: 13 Columns: 3 $ INSEE_REG &lt;chr&gt; &quot;11&quot;, &quot;24&quot;, &quot;27&quot;, &quot;28&quot;, &quot;32&quot;, &quot;44&quot;, &quot;52&quot;, &quot;53&quot;, &quot;75&quot;, &quot;76&quot;, &quot;84&quot;, &quot;93&quot;, &quot;94&quot; $ AREA [m^2] 12064965602 [m^2], 39470090934 [m^2], 47980511542 [m^2], 30102357519 [m^2], 32008524600 ... $ geometry &lt;GEOMETRY [m]&gt; POLYGON ((670067.7 6886751,..., POLYGON ((690554.9 6713339,..., POLYGON ((99688... On voit que summarise permet non seulement dagréger nos données attributaires, mais également les géométries. Cette opération permet donc de retrouver directement notre carte des régions métropolitaines. mapview(regions, zcol = &quot;INSEE_REG&quot;, legend = F) On peut enfin effectuer des jointures attributaines sur nos données en utilisant les verbes à deux dataframe de dplyr. Par exemple on va pouvoir récupérer, dans la table regions_geo de notre RData, les libellées de nos régions. regions &lt;- regions %&gt;% left_join(regions_geo %&gt;% st_drop_geometry(), by = c(&quot;INSEE_REG&quot;) ) Nous pouvons alors utiliser ce nouvelle attribut pour nos cartes. mapview(regions, zcol = &quot;NOM_REG&quot;, legend = F) Attention, quand vous réalisez une jointure entre deux tables de données : X %&gt;% ZZ_join(Y) La composante spatiale nest conservée que pour la première table X. "],["les-opérations-spatiales-sur-les-données.html", "Chapitre 6 Les opérations spatiales sur les données 6.1 Filtrer 6.2 Prédicats spatiaux 6.3 Les jointures spatiales 6.4 Les calculs de distance", " Chapitre 6 Les opérations spatiales sur les données Les opérations spatiales sont des opérations prenant nos données en entrée pour en sortir un résultat dépendant de leur composante spatiale (forme, localisation). Dans ce chapitre, nous allons utiliser les packages suivants. library(sf) library(tidyverse) library(mapview) library(ggplot2) Nous utiliserons les données de la table des régions de la France métropolitaine et des établissements publics de coopération intercommunale (EPCI)6 de la France Métropolitaine load(&quot;data/admin_express.RData&quot;) glimpse(epci_geo) Rows: 1,232 Columns: 5 $ ID &lt;chr&gt; &quot;EPCI00000000000000000001&quot;, &quot;EPCI00000000000000000002&quot;, &quot;EPCI00000000000000000003&quot;, &quot;EPC... $ CODE_EPCI &lt;chr&gt; &quot;200000172&quot;, &quot;200000438&quot;, &quot;200000545&quot;, &quot;200000628&quot;, &quot;200000800&quot;, &quot;200000925&quot;, &quot;200000933... $ NOM_EPCI &lt;chr&gt; &quot;CC Faucigny-Glières&quot;, &quot;CC du Pays de Pontchâteau Saint-Gildas-des-Bois&quot;, &quot;CC des Portes... $ TYPE_EPCI &lt;chr&gt; &quot;CC&quot;, &quot;CC&quot;, &quot;CC&quot;, &quot;CC&quot;, &quot;CC&quot;, &quot;CC&quot;, &quot;CC&quot;, &quot;CC&quot;, &quot;CC&quot;, &quot;CC&quot;, &quot;CA&quot;, &quot;CC&quot;, &quot;CC&quot;, &quot;CC&quot;, &quot;CC&quot;... $ geometry &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((964684.4 65..., MULTIPOLYGON (((316650.4 67..., MULTIPOLYGO... glimpse(departements_geo) Rows: 96 Columns: 8 $ ID &lt;chr&gt; &quot;DEP000000000000000000001&quot;, &quot;DEP000000000000000000002&quot;, &quot;DEP000000000000000000003&quot;, &quot;DEP... $ NOM_DEP &lt;chr&gt; &quot;Ain&quot;, &quot;Aisne&quot;, &quot;Allier&quot;, &quot;Alpes-de-Haute-Provence&quot;, &quot;Hautes-Alpes&quot;, &quot;Alpes-Maritimes&quot;, ... $ NOM_DEP_M &lt;chr&gt; &quot;AIN&quot;, &quot;AISNE&quot;, &quot;ALLIER&quot;, &quot;ALPES DE HAUTE PROVENCE&quot;, &quot;HAUTES ALPES&quot;, &quot;ALPES MARITIMES&quot;, ... $ INSEE_DEP &lt;chr&gt; &quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;... $ INSEE_REG &lt;chr&gt; &quot;84&quot;, &quot;32&quot;, &quot;84&quot;, &quot;93&quot;, &quot;93&quot;, &quot;93&quot;, &quot;84&quot;, &quot;44&quot;, &quot;76&quot;, &quot;44&quot;, &quot;76&quot;, &quot;76&quot;, &quot;93&quot;, &quot;28&quot;, &quot;84&quot;... $ CHF_DEP &lt;chr&gt; &quot;01053&quot;, &quot;02408&quot;, &quot;03190&quot;, &quot;04070&quot;, &quot;05061&quot;, &quot;06088&quot;, &quot;07186&quot;, &quot;08105&quot;, &quot;09122&quot;, &quot;10387&quot;... $ geometry &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((838383.2 65..., MULTIPOLYGON (((708719 6956..., MULTIPOLYGO... $ AREA [m^2] 5774273633 [m^2], 7418609601 [m^2], 7365633524 [m^2], 6994210238 [m^2], 5685029372 [m^2]... glimpse(regions_geo) Rows: 13 Columns: 6 $ ID &lt;chr&gt; &quot;REG000000000000000000001&quot;, &quot;REG000000000000000000002&quot;, &quot;REG000000000000000000003&quot;, &quot;REG... $ NOM_REG &lt;chr&gt; &quot;Auvergne-Rhône-Alpes&quot;, &quot;Bourgogne-Franche-Comté&quot;, &quot;Bretagne&quot;, &quot;Centre-Val de Loire&quot;, &quot;C... $ NOM_REG_M &lt;chr&gt; &quot;AUVERGNE RHONE ALPES&quot;, &quot;BOURGOGNE FRANCHE COMTE&quot;, &quot;BRETAGNE&quot;, &quot;CENTRE VAL DE LOIRE&quot;, &quot;C... $ INSEE_REG &lt;chr&gt; &quot;84&quot;, &quot;27&quot;, &quot;53&quot;, &quot;24&quot;, &quot;94&quot;, &quot;44&quot;, &quot;32&quot;, &quot;28&quot;, &quot;75&quot;, &quot;76&quot;, &quot;52&quot;, &quot;93&quot;, &quot;11&quot; $ CHF_REG &lt;chr&gt; &quot;69123&quot;, &quot;21231&quot;, &quot;35238&quot;, &quot;45234&quot;, &quot;2A004&quot;, &quot;67482&quot;, &quot;59350&quot;, &quot;76540&quot;, &quot;33063&quot;, &quot;31555&quot;... $ geometry &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((985059.5 65..., MULTIPOLYGON (((880572.7 67..., MULTIPOLYGO... 6.1 Filtrer Nous souhaitons par exemple filtrer nos EPCI sur les EPCI du département de Loire-Atlantique. departement_44 &lt;- departements_geo %&gt;% filter(INSEE_DEP == &quot;44&quot;) epci_d44 &lt;- epci_geo[departement_44, , op = st_within] mapview(list(departement_44, epci_d44), zcol = c(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;), legend = F) Lopération de filtre sur les données spatiales fonctionne en prenant la table en entrée (epci_geo), la table avec laquelle on souhaite définir les lignes à garder (departement_44),et lopérateur qui va définir le test entre les deux géométries. Ici cet opérateur est st_within(x,y), qui renvoie TRUE si la géométrie de x est contenue à lintérieur de celle de y. On peut spécifier différents prédicats spatiaux pour réaliser ce filtre. En deuxième argument (, ,), on peut rajouter, comme dans une opération [ classique de R les colonnes que lon souhaite garder. On voit ici que le résultat nest pas très concluant : il manque 3 epci du département, ceux qui sortent des frontières de celui-ci. Prenons un buffer autour du département. Quest ce quun buffer ? Cest un tampon qui va nous permettre dappliquer une transformation sur un objet vectoriel. A partir dune couche de départ de type ponctuel, linéaire ou polygonal, le buffer va créer une nouvelle couche vectorielle. La géométrie de cette couche représente des objets surfaciques dont les frontières sont positionnées à une distance euclidienne, définie par lutilisateur, des limites des objets vectoriels de la couche de départ. La fonction qui permet de faire cela avec sf sappelle st_buffer(). st_buffer() prend en paramètre : un objet de classe sf une distance dont lunité est définie par celle de lobjet sf, que lon peut obtenir comme ceci st_crs(x)$units. departement_44_buffer &lt;- departement_44 %&gt;% st_buffer(dist = 5000) mapview(list(departement_44_buffer, departement_44), layer.name = c(&quot;Loire-Atlantique avec un buffer de 5 km&quot;, &quot;Loire-Atlantique&quot;), zcol = c(&quot;NOM_DEP&quot;, &quot;NOM_DEP&quot;), col.regions = list(&quot;#440154FF&quot;, &quot;#FDE725FF&quot;)) epci_d44_buffer &lt;- epci_geo[departement_44_buffer, , op = st_within] mapview(list(departement_44_buffer, epci_d44_buffer), zcol = c(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;), legend = F) On récupère 2 des 3 epci manquant ainsi. Celui qui manque est lEpci de Redon qui est à cheval sur la Loire-Atlantique, le Morbihan et lIle et Vilaine. Une méthode pour le récupérer est de prendre lopérateur de filtre st_intersect au lieu de st_within en utilisant un buffer légèrement négatif de notre département pour ne pas récupérer les epci limitrophes. departement_44_buffer_negatif &lt;- departement_44 %&gt;% st_buffer(dist = -2000) epci_d44 &lt;- epci_geo[departement_44_buffer_negatif, , op = st_intersects] mapview(list(departement_44, epci_d44), zcol = c(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;), legend = F) 6.2 Prédicats spatiaux Les prédicats spatiaux décrivent les relations spatiales entre objets. Pour bien les illustrer on va utiliser quelques données de test. Nous allons utiliser un polygone (a), des lignes (l) et des points (p). # polygone (a) a_poly &lt;- st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1)))) a &lt;- st_sfc(a_poly) # ligne (l) l1 &lt;- st_multilinestring(list(rbind(c(0.5, -1), c(-0.5, 1)))) l2 &lt;- st_multilinestring(list(rbind(c(.9, -.9), c(.5, 0)))) l &lt;- st_sfc(l1, l2) # multipoints (p) p_matrix &lt;- matrix(c(0.5, 1, -1, 0, 0, 1, 0.5, 1), ncol = 2) p_multi &lt;- st_multipoint(x = p_matrix) p &lt;- st_cast(st_sfc(p_multi), &quot;POINT&quot;) A partir de ces objets, on peut se poser les questions suivantes : Quels sont les points de p contenus dans le triangle a ? Quels sont les points de p qui ne sont pas contenus dans le triangle a ? Quels sont les points de p qui touchent le triangle a ? Quelles sont les lignes de l contenues dans a ? Les prédicats spatiaux vont nous permettre de répondre à ces questions. sf contient une liste de fonctions qui permettent chacune de répondre à lune ou lautre de ces questions. st_intersects() permet de répondre à la première question, à savoir quels points de p sont dans a. st_intersects(p, a) Sparse geometry binary predicate list of length 4, where the predicate was `intersects&#39; 1: 1 2: 1 3: (empty) 4: (empty) Lopposé de st_intersects() est st_disjoint() : st_disjoint(x,y) renvoie TRUE pour les objets de x non reliés à y. st_disjoint(p, a) Sparse geometry binary predicate list of length 4, where the predicate was `disjoint&#39; 1: (empty) 2: (empty) 3: 1 4: 1 Le résultat de cette opération est une liste. Par défaut, la fonction st_intersect() renvoie une matrice creuse7. Cette structure permet déconomiser de la mémoire en nenregistrant que les relations qui existent. Sur une opération de ce type, le gain est peu évident, mais quand on travail sur des objets plus complexes, le gain est appréciable. Si on souhaite mieux utiliser cette information, on peut vouloir privilégier la matrice dense, qui renvoie une matrice de booléen pour chaque relation possible. Pour cela on peut utiliser loption sparse=F. st_intersects(p, a, sparse = F) [,1] [1,] TRUE [2,] TRUE [3,] FALSE [4,] FALSE st_within() est une variante de st_intersect() qui ne renvoie TRUE que pour les points à lintérieur du polygone. st_within(p, a, sparse = F) [,1] [1,] TRUE [2,] FALSE [3,] FALSE [4,] FALSE Une variante de st_within() permet dajouter un critère de distance pour intégrer des points presque dans le polygone, st_is_within_distance(). st_is_within_distance(p, a, dist = 0.8) Sparse geometry binary predicate list of length 4, where the predicate was `is_within_distance&#39; 1: 1 2: 1 3: (empty) 4: 1 st_touches() permet de récupérer les points qui touchent le polygone sans sans être à lintérieur du polygone. st_touches(p, a, sparse = F) [,1] [1,] FALSE [2,] TRUE [3,] FALSE [4,] FALSE st_contains(x,y) est équivalent à st_within(y,x). Par exemple si nous voulons savoir lesquelles de nos lignes l sont contenues dans a. st_contains(a, l, sparse = F) [,1] [,2] [1,] FALSE TRUE Equivalent à : st_within(l, a, sparse = F) [,1] [1,] FALSE [2,] TRUE st_crosses() renvoie TRUE si lintersection des deux géométries est une géométrie de dimension n-1 ou n est le maximum des dimensions des deux objets et si lintersection est à lintérieur des deux objets. st_crosses(l, a, sparse = F) [,1] [1,] TRUE [2,] FALSE Il existent encore dautres prédicats quon ne détaillera pas ici : st_covers() st_covered_by() st_equals() et st_equals_exact() st_contains_properly() st_overlaps() 6.2.1 Exercices Créer un objet des points de p qui intersectent avec le polygone a 6.3 Les jointures spatiales Les jointures attributaires se basent sur un appariement sur une liste des variables présentes dans les deux tables. Les jointures spatiales se basent sur un appariement sur un espace geographique commun. 6.3.1 Jointure de points avec des polygones Ce cas est relativement simple, une jointure spatiale entre une liste de points et une liste de polygones va attribuer pour chaque point le polygone auquel il appartient. On va utiliser ici le fichier sirene du département de Loire Atlantique géocodé par Christian Quest8. Prenons les entreprises de production de sel sur ce département et regardons dans quelle partie du territoire elles se trouvent. load(&quot;data/sirene.RData&quot;) sirene44_sel &lt;- sirene44 %&gt;% filter(APET700 == &quot;0893Z&quot;) mapview(list(departement_44, epci_d44, sirene44_sel), zcol = c(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;, &quot;NOMEN_LONG&quot;), legend = F) Nous allons réaliser une jointure spatiale pour récupérer le code sirene de lEPCI où se trouve chaque entreprise. sirene44_sel_avec_code_epci &lt;- sirene44_sel %&gt;% st_join(epci_geo) mapview(list(departement_44, epci_d44, sirene44_sel_avec_code_epci), zcol = c(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;, &quot;NOM_EPCI&quot;), legend = F) Une jointure entre deux couches de données géographique demande à ce que celles-ci partagent la même projection. 6.3.2 Jointure de polygones avec des polygones A la différence des appariements entre points et polygones, la jointure spatiales entre deux couches de polygones nécessite quelques critères complémentaires : souhaite-t-on joindre deux polygones dès quils sintersectent ? Souhaite-t-on joindre à un polygone de la première couche à celui de la deuxième avec lequel il partage le plus de surface en commun ? Par exemple, imaginons que nous voulions joindre notre couche des epci avec celle des départements, souhaite-t-on que lEPCI de Redon se retrouve apparié avec tous les départements dans lesquels il se retrouve, ou seulement le département dans lequel il est principalement situé ? epci_d44_avec_departement &lt;- epci_d44 %&gt;% st_join(departements_geo %&gt;% st_buffer(dist = -1000)) epci_d44_avec_departement %&gt;% select(NOM_EPCI, NOM_DEP) %&gt;% group_by(NOM_EPCI) %&gt;% tally() %&gt;% arrange(-n) # A tibble: 17 x 3 NOM_EPCI n geometry &lt;chr&gt; &lt;int&gt; &lt;MULTIPOLYGON [m]&gt; 1 CA Redon Agglomération 3 (((306623.5 6741727, 306242.5 6741883, 305602.7 6742118, 3055~ 2 CA de la Presqu&#39;île de Guérande Atlant~ 2 (((276740.4 6716295, 276731.6 6716306, 276724.3 6716291, 2767~ 3 CC du Pays d&#39;Ancenis 2 (((368752 6717819, 368723.8 6717821, 368302 6717946, 368143.4~ 4 CA Clisson Sèvre et Maine Agglo 1 (((377846 6675063, 377875.1 6675064, 377905.6 6675050, 377960~ 5 CA de la Région Nazairienne et de l&#39;Es~ 1 (((296085.7 6697957, 296023.1 6697783, 296007.6 6697761, 2957~ 6 CA Pornic Agglo Pays de Retz 1 (((304025.3 6684737, 304057.2 6684904, 304108.9 6684991, 3041~ 7 CC Châteaubriant-Derval 1 (((352473.9 6745979, 352463.6 6746000, 352442.9 6746125, 3524~ 8 CC d&#39;Erdre et Gesvres 1 (((344439 6712389, 344500.3 6712440, 344533.6 6712504, 344640~ 9 CC de Grand Lieu 1 (((350701.8 6678585, 350710.7 6678630, 350792.7 6678700, 3507~ 10 CC de la Région de Blain 1 (((347277.1 6718325, 347241.9 6718337, 347188.6 6718338, 3471~ 11 CC de Nozay 1 (((348977.2 6729779, 349279.8 6730100, 349309.8 6730099, 3493~ 12 CC du Pays de Pontchâteau Saint-Gildas~ 1 (((316650.4 6727168, 316716 6727700, 316721.5 6727722, 316814~ 13 CC du Sud-Estuaire 1 (((312929 6700671, 313038.5 6700721, 313134.2 6700753, 313313~ 14 CC Estuaire et Sillon 1 (((321954.7 6705420, 321910 6705825, 321141.1 6706100, 320580~ 15 CC Sèvre et Loire 1 (((369365.5 6686430, 369203.9 6686525, 368865.3 6686806, 3687~ 16 CC Sud Retz Atlantique 1 (((338804.8 6658661, 338783.6 6658652, 338773.2 6658622, 3387~ 17 Nantes Métropole 1 (((343448 6696675, 343551 6697017, 343478.2 6697111, 343478 6~ Une jointure classique va donc rattacher 3 epci à plus de 1 département. Avec loption largest=T la jointure va attribuer aux epci le département avec lequel il partage le plus de surface. On voit ici que tout les epci adhérents à la Loire Atlantique se retrouvent alors rattachés à la Loire Atlantique. epci_d44_avec_departement &lt;- epci_d44 %&gt;% st_join(departements_geo %&gt;% st_buffer(dist = -1000), largest = T) mapview(list(departement_44, epci_d44, sirene44_sel_avec_code_epci), zcol = c(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;, &quot;NOM_EPCI&quot;), legend = F) 6.3.3 Exercice Le but de cet exercice va être dexploiter les données DVF sur les transactions immobilières dans lancien et la carte des quartiers de Nantes pour obtenir un prix moyen des transactions par quartier. On va utiliser pour DVF lAPI mise en place par Christian Quest. Données DVF : http://api.cquest.org/dvf Contour des quartiers de Nantes : https://data.nantesmetropole.fr/explore/dataset/244400404_quartiers-nantes/information/?disjunctive.nom On veut produire les infos suivantes par quartier et année : Volume de ventes Pourcentage de maisons dans les ventes Prix moyen au m2 par type de bien 6.4 Les calculs de distance 6.4.1 Matrice de distances Contrairement aux opérations précédentes qui sont binaires, les opérations de distance sont continues. Les distances se calculent avec la fonction st_distance(). centres_departements_pdl &lt;- st_centroid(departements_geo) %&gt;% filter(INSEE_REG == &quot;52&quot;) st_distance(centres_departements_pdl) Units: [m] [,1] [,2] [,3] [,4] [,5] [1,] 0.00 84534.14 115940.12 159007.12 81693.02 [2,] 84534.14 0.00 84436.05 89197.31 97167.70 [3,] 115940.12 84436.05 0.00 67721.05 170454.77 [4,] 159007.12 89197.31 67721.05 0.00 186162.73 [5,] 81693.02 97167.70 170454.77 186162.73 0.00 Trois choses à noter sur le résultat : st_distance() retourne une matrice  contenant toute les distances calculables 2 à 2 et qui a un paramètre Units nous donnant lunité de mesure des distances calculées. Ici on calcule notre matrice sur un seul objet. Vous pouvez calculer des distances entre deux objets x et y de classe sf. Dans ce cas il fera le calcul des distances pour toutes les combinaisons possibles dobjets de x et de y. Une option de st_distance() vous permet de limiter le résultat aux calculs 2 à 2 : by_element = T. Dans ce cas le résultat est un vecteur. 6.4.2 Identification du plus proche voisin Un besoin fréquent en traitement géomatique est didentifier lobjet le plus proche dun autre. La fonction qui permet cela est st_nearest_feature(). Prenons lensemble des départements français, et trouvons celui de la région le plus proche. On va utiliser les centroïdes pour alléger le calcul. index_dep_pdl &lt;- st_nearest_feature( departements_geo, centres_departements_pdl ) st_nearest_feature() renvoie un vecteur dindex en résultat. Pour visualiser cet index, vous pouvez utiliser ensuite la fonction st_nearest_point() qui va permettre de faire un lien entre les départements et le département ligérien le plus proche. st_nearest_point() permet en effet de renvoyer pour deux géométries la ligne rejoignant les 2 points les plus proches. liens &lt;- st_nearest_points(departements_geo, centres_departements_pdl[index_dep_pdl, ], pairwise = TRUE ) ggplot() + geom_sf(data = departements_geo) + geom_sf(data = liens) On peut utiliser aussi st_nearest_feature() comme un mode de jointure des données. departements_join &lt;- st_join(departements_geo, centres_departements_pdl, join = st_nearest_feature ) ggplot() + geom_sf(data = departements_join, aes(fill = NOM_DEP.y)) + labs( title = &quot;Département ligérien le plus proche de chaque département français&quot;, fill = NULL ) https://fr.wikipedia.org/wiki/%C3%89tablissement_public_de_coop%C3%A9ration_intercommunale https://fr.wikipedia.org/wiki/Matrice_creuse http://data.cquest.org/geo_sirene/ "],["les-opérations-géométriques.html", "Chapitre 7 Les opérations géométriques 7.1 Opérations unaires 7.2 Opérations binaires", " Chapitre 7 Les opérations géométriques Nous allons voir dans ce chapitre comment opérer des opérations géométriques sur nos vecteurs. Dans ce chapitre, nous allons utiliser les packages suivants. library(sf) library(tidyverse) library(mapview) library(ggplot2) library(rmapshaper) On distingue deux types dopérations : les opérations unaires et binaires. 7.1 Opérations unaires 7.1.1 Simplification La simplification revient comme son nom lindique à simplifier une couche vectorielle. Le cas dusage dun tel procédé peut être un changement déchelle et plus généralement le besoin de réduire la taille de stockage de notre objet (par exemple pour une publication ou une carte interactive). Le package sf contient une fonction st_simplify qui implémente lalgorithme de Douglas-Peucker9 de GEOS. La fonction utilise le paramètre dTolerance pour controler le niveau de simplification. load(&quot;data/admin_express.RData&quot;) departement_56 &lt;- departements_geo %&gt;% filter(INSEE_DEP == &quot;56&quot;) departement_56_simplifie &lt;- departement_56 %&gt;% st_simplify(dTolerance = 900) departement_56_super_simplifie &lt;- departement_56 %&gt;% st_simplify(dTolerance = 2000) p1 &lt;- ggplot() + geom_sf(data = departement_56) + theme_void() + theme(panel.grid = element_blank(), panel.border = element_blank()) p2 &lt;- ggplot() + geom_sf(data = departement_56_simplifie) + theme_void() p3 &lt;- ggplot() + geom_sf(data = departement_56_super_simplifie) + theme_void() p1 + p2 + p3 + plot_layout(nrow = 1) On peut mesurer le gain réalisé par chaque opération. Une simplification avec un dTolerance de 900 permet déconomiser 96.9 % du stockage. Une simplification avec un dTolerance de 2000 permet déconomiser 97.7 % du stockage. object.size(departement_56) 505744 bytes object.size(departement_56_simplifie) 15720 bytes object.size(departement_56_super_simplifie) 11768 bytes Le problème de lalgorithme Douglas-Peucker est quil simplifie les géométries objet par objet. Cela conduit à perdre la topologie, et à des trous ou des chevauchements. Loption preserveTopology = T de st_simplify() doit permettre en théorie déviter ce problème, mais ne marche pas au delà dun certain seuil. Par exemple, prenons 2 départements autour du Morbihan. departements_35_44_56 &lt;- departements_geo %&gt;% filter(INSEE_DEP %in% c(&quot;35&quot;, &quot;44&quot;, &quot;56&quot;)) departements_35_44_56_super_simplifie &lt;- departements_35_44_56 %&gt;% st_simplify(dTolerance = 3000) p1 &lt;- ggplot() + geom_sf(data = departements_35_44_56) + theme_void() + theme(panel.grid = element_blank(), panel.border = element_blank()) p3 &lt;- ggplot() + geom_sf(data = departements_35_44_56_super_simplifie) + theme_void() p1 + p3 + plot_layout(nrow = 1) On constate clairement des trous à la frontière des 3 départements. Un autre algorithme peut être utilisé qui na pas les mêmes limitations, lalgorithme de Visvalingam10. Le package rmapshaper contient une fonction ms_simplify() qui implémente cet algorithme. Ce package est une interface vers Mapshaper11, un site en ligne dédition de données cartographiques. departements_35_44_56 &lt;- departements_35_44_56 %&gt;% mutate(AREA = as.numeric(AREA)) departements_35_44_56_ms_simplifie &lt;- ms_simplify(departements_35_44_56, method = &quot;vis&quot;, keep = 0.01) p1 &lt;- ggplot() + geom_sf(data = departements_35_44_56) + theme_void() + theme(panel.grid = element_blank(), panel.border = element_blank()) p3 &lt;- ggplot() + geom_sf(data = departements_35_44_56_ms_simplifie) + theme_void() p1 + p3 + plot_layout(nrow = 1) 7.1.2 Centroïde Le centroïde permet didentifier le centre dun objet géométrique. Il y a plusieurs façons de définir un centroïde. La plus usuelle est le centroïde géographique, qui peut être défini comme le point déquilibre dun objet (celui en dessous duquel votre doigt peut faire tenir en équilibre cet objet). La fonction permettant de définir un centroïde dans sf est st_centroid(). centres_departements &lt;- st_centroid(departements_geo) ggplot() + geom_sf(data = departements_geo) + geom_sf(data = centres_departements, color = &quot;dark green&quot;, size = .5) + theme_void() + theme(panel.grid = element_blank(), panel.border = element_blank()) + labs(title = &quot;les départements et leur centroïdes&quot;) Parfois, le centroïde peut se placer en dehors de lobjet lui même. Par exemple pensez à un atoll. Dans ce cas on peut utiliser st_point_on_surface() qui garantit que le point est sur la surface de lobjet de départ. 7.1.3 Buffer Comme déjà vu, à partir dune couche de départ de type ponctuel, linéaire ou polygonal, le buffer va créer une nouvelle couche vectorielle. La géométrie de cette couche représente des objets surfaciques dont les frontières sont positionnées à une distance euclidienne, définie par lutilisateur, des limites des objets vectoriels de la couche de départ. departement_44_buffer &lt;- departement_44 %&gt;% st_buffer(dist = 5000) mapview(list(departement_44_buffer, departement_44), layer.name = c(&quot;Loire-Atlantique avec un buffer de 5 km&quot;, &quot;Loire-Atlantique&quot;), zcol = c(&quot;NOM_DEP&quot;, &quot;NOM_DEP&quot;), col.regions = list(&quot;#440154FF&quot;, &quot;#FDE725FF&quot;)) 7.2 Opérations binaires 7.2.1 Transformation affine Les tranformations affines regrouppent les transformations qui préservent les lignes et le parallélisme. A linverse les angles et les tailles ne le sont pas forcément. Les transformations affines intègrent notamment les translations, les rotations et les changements déchelle. Le package sf implémente ces transformations pour les objets de classe sfg et sfc. 7.2.1.1 Translation departement_44_sfc &lt;- st_geometry(departement_44) departement_44_sfc_trans &lt;- departement_44_sfc + c(10000, 10000) departement_44_trans &lt;- st_set_geometry(departement_44, departement_44_sfc_trans) st_crs(departement_44_trans) &lt;- st_crs(departement_44) mapview(list(departement_44_trans, departement_44), layer.name = c(&quot;Loire-Atlantique avec déplacement affine de 10 km vers le nord et 10 km vers le sud&quot;, &quot;Loire-Atlantique&quot;), zcol = c(&quot;NOM_DEP&quot;, &quot;NOM_DEP&quot;), col.regions = list(&quot;#440154FF&quot;, &quot;#FDE725FF&quot;)) 7.2.1.2 Changement déchelle Dans lexemple suivant on va réduire par deux la surface de chacun des epci du département. Pour cela on va recentrer les epci pour que les coodonnées des centroids soient à lorigine avant de diviser par deux les cordonnées des contours et réappliquer la translation au centroid. epci_d44_sfc &lt;- st_geometry(epci_d44) epci_d44_centroid_sfc &lt;- st_centroid(epci_d44_sfc) epci_d44_centroid_sfc_scale &lt;- (epci_d44_sfc - epci_d44_centroid_sfc) * 0.5 + epci_d44_centroid_sfc epci_d44_centroid_scale &lt;- st_set_geometry(epci_d44, epci_d44_centroid_sfc_scale) st_crs(epci_d44_centroid_scale) &lt;- st_crs(epci_d44) mapview(list(epci_d44, epci_d44_centroid_scale), layer.name = c(&quot;Epci de Loire-Atlantique&quot;, &quot;Epci de Loire-Atlantique avec surface divisées par deux&quot;), zcol = c(&quot;NOM_EPCI&quot;, &quot;NOM_EPCI&quot;), col.regions = list(&quot;#440154FF&quot;, &quot;#FDE725FF&quot;), legend = F) 7.2.2 Découpage Le découpage spatiale est une forme de filtre sur les géographies. Le découpage peut seulement sappliquer à des formes plus complexes que des points : (multi-)lignes, (multi-)polygones. Nous allons illustrer le découpage à partir des epci à cheval sur plusieurs départements. epci_redon &lt;- epci_d44 %&gt;% filter(CODE_EPCI == &quot;243500741&quot;) st_intersection() permet de ne garder que la partie commune des deux géométries redon_et_departement_44 &lt;- st_intersection(epci_redon, departement_44) %&gt;% mutate(NOM_EPCI = &quot;Communes du 44 de la CA Redon Agglomération&quot;) st_difference(x,y) permet de ne garder que la partie de x non présente dans y redon_hors_departement_44 &lt;- st_difference(epci_redon, departement_44) %&gt;% mutate(NOM_EPCI = &quot;Communes du 44 et du CA Redon Agglomération hors communes en commun&quot;) st_sym_difference(x,y) permet de ne garder que les partie de x et de y non communes. redon_et_departement_44_sans_partie_communes &lt;- st_sym_difference(epci_redon, departement_44) %&gt;% mutate(NOM_EPCI = &quot;Communes du 44 et du CA Redon Agglomération hors communes en commun&quot;) 7.2.3 Union Union permet de fusionner les géométries de plusieurs objets. On va regarder comment reconsituer la carte des communes à partir de celle des départements regions &lt;- departements_geo %&gt;% group_by(INSEE_REG) %&gt;% summarise(do_union = T) mapview(regions, legend = F) Derrière cette opération, summarise() utilise st_union() du package sf pour dissourdre les polygones des départements en un seul polygone régional. regions_52 &lt;- departements_geo %&gt;% filter(INSEE_REG == &quot;52&quot;) regions_52 &lt;- st_union(regions_52) Douglas, David H, and Thomas K Peucker. 1973. Algorithms for the Reduction of the Number of Points Required to Represent a Digitized Line or Its Caricature. Cartographica: The International Journal for Geographic Information and Geovisualization 10 (2): 11222. Visvalingam, M., and J. D. Whyatt. 1993. Line Generalisation by Repeated Elimination of Points. The Cartographic Journal 30 (1): 4651. https://doi.org/10.1179/000870493786962263. https://mapshaper.org/ "],["les-reprojections.html", "Chapitre 8 Les reprojections 8.1 Un premier exemple de reprojection 8.2 Quand reprojeter ? 8.3 Quel CRS utiliser ? 8.4 Comment projeter ?", " Chapitre 8 Les reprojections Dans ce chapitre, nous allons utiliser les librairies suivantes. library(sf) library(tidyverse) library(ggplot2) library(patchwork) library(lwgeom) Pour rappel, il existe deux types de CRS, les CRS géographiques (longitude/lattitude avec pour unité de compte des degrés) et les CRS projetés (avec un datum et une unité en mètre par exemple). La plupart des fonctions de sf présupposent sappliquer sur un CRS projeté, car les fonctions de GEOS sur lesquelles elles se basent le font aussi. 8.1 Un premier exemple de reprojection Prenons les coordonnées de Nantes en WGS 84: nantes&lt;-data.frame(lon=-1.553621,lat=47.218371) %&gt;% st_as_sf(coords = c(&quot;lon&quot;, &quot;lat&quot;)) %&gt;% st_set_crs(4326) On peut visualiser nos données mapview(nantes) st_is_longlat() est une fonction de sf qui permet de faire un test sur la famille de CRS à laquelle on a à faire. st_is_longlat(nantes) [1] TRUE Essayons de créer un buffer de 1km autour de Nantes nantes_buffer= st_buffer(nantes, dist = 1) Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle, : st_buffer does not correctly buffer longitude/latitude data mapview(list(nantes,nantes_buffer)) Le message est clair et indique quun buffer ne marchera pas correctement sur des données en projection longitude / lattitude. Tentons une reprojection. La fonction permettant une reprojection est st_transform(). On va ici passer en lambert 93 nos données. nantes_proj&lt;-st_transform(nantes, 2154) Le CRS lambert 93 est bien un CRS projeté : st_is_longlat(nantes_proj) [1] FALSE nantes_proj_buffer= st_buffer(nantes_proj, dist = 1) mapview(list(nantes_proj,nantes_proj_buffer)) 8.2 Quand reprojeter ? Quelques cas usuels qui peuvent vous amener à reprojeter vos données : la manipulation de données fournies dans des CRS différents lusage du package leaflet impose des données spécifiées en WGS 84 le besoin de visualiser vos données suivant la conversion de certaines propriétés des objets à la surface de la terre. lusage de fonctions demandant à utiliser des CRS projetés (comme st_buffer() ci-dessus) Un exemple dusage : la distance de Rennes à Nantes Prenons les coordonnées WGS 84 de Rennes rennes&lt;-data.frame(lon=-1.6777926,lat=48.117266) %&gt;% st_as_sf(coords = c(&quot;lon&quot;, &quot;lat&quot;)) %&gt;% st_set_crs(4326) mapview(rennes) Tentons de calculer la distance de Rennes à Nantes. Avec la données en Lambert 93, la fonction st_distance() renvoie un message derreur. st_distance(rennes,nantes_proj) Error in st_distance(rennes, nantes_proj): st_crs(x) == st_crs(y) is not TRUE Avec la données en WGS 84, la fonction st_distance() renvoie bien le résultat. st_distance(rennes,nantes) Units: [m] [,1] [1,] 100376.7 8.3 Quel CRS utiliser ? A cette question, il y a rarement une bonne réponse. En ce qui concerne les CRS géométriques, le plus simple est dutiliser le WGS 84, qui est de loin le plus populaire, avec lequel beaucoup de données sont fournies. En ce qui concerne les CRS projetés, utiliser par défaut le lambert 93, le CRS officiel français, pour les données nationales fait sens. Ensuite votre choix va dépendre des propriétés que vous souhaitez conserver. 8.4 Comment projeter ? 8.4.1 Projeter des vecteurs Reprojeter des données vecteur se fait à laide de la fonction st_transform() que nous avons vu en utilisant le code epsg que nous voulons. 8.4.2 Modifier la projection dune carte. Parfois on souhaite pouvoir aller plus loin dans les reprojections, en adaptant le centre de la projection, pour cela on peut utiliser un proj4string ad hoc. Pour cela, on va modifier largument +proj de notre crs avec st_transform. Tentons par exemple de reprojeter notre carte du globe en utilisant la projection azimutale équivalente de Lambert, centrée sur Pékin. data(&quot;World&quot;) World_pekin&lt;-st_transform(World,crs = &quot;+proj=laea +x_0=0 +y_0=0 +lon_0=116 +lat_0=40&quot;) Le paramètre +proj=laea permet de redéfinir la projection, les paramètres +lon_0 et lat_0 permettent de définir le centre de la projection. x_0 et y_0 définissent le centre du plan pour les coordonnées. Quest ce qui a changé entre nos deux cartes ? st_crs(World) Coordinate Reference System: User input: +proj=eck4 +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs wkt: PROJCRS[&quot;unknown&quot;, BASEGEOGCRS[&quot;unknown&quot;, DATUM[&quot;World Geodetic System 1984&quot;, ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, LENGTHUNIT[&quot;metre&quot;,1]], ID[&quot;EPSG&quot;,6326]], PRIMEM[&quot;Greenwich&quot;,0, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8901]]], CONVERSION[&quot;unknown&quot;, METHOD[&quot;Eckert IV&quot;], PARAMETER[&quot;Longitude of natural origin&quot;,0, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8802]], PARAMETER[&quot;False easting&quot;,0, LENGTHUNIT[&quot;metre&quot;,1], ID[&quot;EPSG&quot;,8806]], PARAMETER[&quot;False northing&quot;,0, LENGTHUNIT[&quot;metre&quot;,1], ID[&quot;EPSG&quot;,8807]]], CS[Cartesian,2], AXIS[&quot;(E)&quot;,east, ORDER[1], LENGTHUNIT[&quot;metre&quot;,1, ID[&quot;EPSG&quot;,9001]]], AXIS[&quot;(N)&quot;,north, ORDER[2], LENGTHUNIT[&quot;metre&quot;,1, ID[&quot;EPSG&quot;,9001]]]] st_crs(World_pekin) Coordinate Reference System: User input: +proj=laea +x_0=0 +y_0=0 +lon_0=116 +lat_0=40 wkt: PROJCRS[&quot;unknown&quot;, BASEGEOGCRS[&quot;unknown&quot;, DATUM[&quot;World Geodetic System 1984&quot;, ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, LENGTHUNIT[&quot;metre&quot;,1]], ID[&quot;EPSG&quot;,6326]], PRIMEM[&quot;Greenwich&quot;,0, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8901]]], CONVERSION[&quot;unknown&quot;, METHOD[&quot;Lambert Azimuthal Equal Area&quot;, ID[&quot;EPSG&quot;,9820]], PARAMETER[&quot;Latitude of natural origin&quot;,40, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8801]], PARAMETER[&quot;Longitude of natural origin&quot;,116, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8802]], PARAMETER[&quot;False easting&quot;,0, LENGTHUNIT[&quot;metre&quot;,1], ID[&quot;EPSG&quot;,8806]], PARAMETER[&quot;False northing&quot;,0, LENGTHUNIT[&quot;metre&quot;,1], ID[&quot;EPSG&quot;,8807]]], CS[Cartesian,2], AXIS[&quot;(E)&quot;,east, ORDER[1], LENGTHUNIT[&quot;metre&quot;,1, ID[&quot;EPSG&quot;,9001]]], AXIS[&quot;(N)&quot;,north, ORDER[2], LENGTHUNIT[&quot;metre&quot;,1, ID[&quot;EPSG&quot;,9001]]]] "],["créer-des-cartes-avec-ggplot2.html", "Chapitre 9 Créer des cartes avec ggplot2 9.1 Quelques rappels sur ggplot2 9.2 Faire des cartes avec ggplot2", " Chapitre 9 Créer des cartes avec ggplot2 Dans ce chapitre, nous allons utiliser les librairies suivantes. library(sf) library(tidyverse) library(ggplot2) library(patchwork) library(lwgeom) #remotes::install_github(&quot;MaelTheuliere/variousdata&quot;) library(variousdata) library(ggspatial) 9.1 Quelques rappels sur ggplot2 9.1.1 Présentation du package ggplot2 ggplot 2 est un package créé par Hadley Wickham et Winston Chang pour implémenter dans R la vision développée par Leland Wilkinson dans The Grammar of Graphics (Statistics and Computing) de la conception de graphiques. Le but est de fournir une approche unique pour produire quasiment toute valorisation graphique de données que lon peut trouver dans des revues scientifiques, les journaux, dans lanalyse statistique ou la data visualisation. Ce package aujourdhui sinscrit dans R dans le framework Tidyverse qui propose une approche cohérente sur lensemble de la chaîne de vie de la donnée : importation, préparation des données, analyse et valorisation. 9.1.2 Le Tidyverse le tidyverse 9.1.3 ggplot 2 : les concepts clefs Pour construire un graphique avec ggplot il va falloir lui définir plusieurs éléments : la donnée : ggplot2 permet de travailler sur des vecteurs, des dataframes, des tibbles, ou des données spatiales ; le mapping : on définit dans laesthetic (ou aes) le mapping, cest à dire ce que lon veut représenter qui dépend des variables (quelle variable sur laxe x, sur laxe y, quelle variable pour définir une graduation de couleurs) ; les paramètres : on définit les autres paramètres qui dépendent de constantes (par exemple : je veux que toutes mes lignes soient rouges ou de taille 2 pixels) ; le layer (forme géométrique) : on définit sous quelle représentation graphique on représente les paramètres précédents. Sous ggplot, ces fonctions sont de la forme geom_XX ; Lécriture type dun graphique sera donc: ggplot(data = &lt;DATA&gt;) + &lt;FORME_GEO&gt;(mapping = aes(&lt;MAPPINGS&gt;),...=&lt;PARAMS&gt;) On va ensuite pouvoir partir de cette base pour lenrichir avec des fonctions supplémentaires. Chaque fonction senchaine avec des + comme les %&gt;%. ggplot(data = &lt;DATA&gt;) + &lt;FORME_GEO&gt;(mapping = aes(&lt;MAPPINGS&gt;),...=&lt;PARAMS&gt;)+ &lt;FONCTION1&gt;+ ... 9.1.4 Le mapping 9.1.4.1 Les paramètres du mapping Dans lexemple qui suit, la représentation géographique utilisée est le nuage de point geom_point(). Dautres types de représentations graphiques sont présentées dans la partie suivante. Laesthetic sert à identifier les variables que lon souhaite représenter. Par exemple, si lon souhaite représenter le taux de mortalité maternelle (Maternal_mortality_ratio) en fonction du produit intérieur brut (Gross_Domestic_Product_GDP) : sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr)) De plus, la fonction aes() admet dautres arguments qui permettent de modifier lapparence du graphique selon une 3ème variable du jeu de données. colour : la couleur, shape : la forme, size : la taille, alpha : la transparence, fill : le remplissage ; sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent)) 9.1.4.2 Les autres paramètres Il est possible de spécifier des paramètres qui seront valables pour lensemble du graphique. On retrouve entre autre les mêmes paramètres que proposés dans laes mais il faut alors les passer en dehors de laesthetic. Par exemple si lon souhaite modifier la transparance et la taille de lensemble des points du graphique précédent: sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) De même si lon souhaite modifier la couleur générale: sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr), color = &quot;red&quot;, alpha = 0.5, size = 1.9 ) Pour choisir et modifier facilement les couleurs dun graphique, il existe un addin développé par Dean Attali: Colour Picker. Il est installable comme nimporte quel package. Pour plus dinformations: https://github.com/daattali/colourpicker 9.1.5 Lhabillage simple 9.1.5.1 Titre et libellé des axes Chaque nouvel élément graphique est à rajouter sous forme de layer, ici nous utilisons la fonction labs() qui permet de labelliser tout les éléments possibles de laesthétic, ainsi que le titre (title), le sous titre (subtitle) et le bas de page (caption) sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) A noter quil existe plusieurs autres façons de spécifier ces élèments par des fonctions spécifiques: ggtitle, xlab, ylab, 9.1.5.2 Légende Les fonctions guide() et guides permettent de modifier finement la légende. Les guides peuvent être spécifiées dans chaque scale_ ou dans une instruction guides. sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) + guides(color = guide_legend( direction = &quot;horizontal&quot;, order = 1, title.position = &quot;top&quot;, title.hjust = 0.5, nrow = 1, label.position = &quot;bottom&quot; )) + theme(legend.position = &quot;bottom&quot;) 9.1.5.3 Annotation Il est aussi possible de rajouter des annotations de type texte, par exemple, à la volée. sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) + annotate(&quot;text&quot;, x = 100000, y = 2, label = &quot;je rajoute mon texte&quot;, color = &quot;blue&quot;) La fonction annotate() permet aussi dajouter dautres types dannotation comme par exemple des rectangles: sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) + annotate(&quot;rect&quot;, xmin = 10, xmax = Inf, ymin = -Inf, ymax = Inf, fill = &quot;red&quot;, alpha = 0.2) + annotate(&quot;rect&quot;, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 2, fill = &quot;green&quot;, alpha = 0.2) 9.1.6 Les thèmes Pour modifier simplement la position de la légende, cest la fonction theme() quil faut utiliser. theme() permet de créer des templates, cest à dire de définir tout ce qui nest pas lié directement aux données sur un graphique, notamment: la position, taille,couleur,police des éléments textuels la couleur des grilles primaires et secondaires du graphique Il existe des thèmes prédéfinis dans ggplot que lon peut déjà utiliser. Par exemple: theme_classic(), theme_bw(), theme_dark(),  Des packages externes permettent denrichir cette collection de thèmes, par exemple ggthemes ou hrbrthemes. Lorsque lon souhaite garder une cohérence entre plusieurs graphiques, le mieux est den définir un à part pour lappeler ensuite. 9.1.6.1 Les fonctions élément Elle utilise 4 types de fonctions: element_text() : pour toutes les étiquettes PARAMÈTRE VALEUR family la famille de la police face le type de police (plain, italic, bold, bold.italic) colour couleur size taille en points hjust justification horizontale, dans [0, 1] vjust justification verticale, dans [0, 1] angle angle, dans [0, 360] lineheight hauteur de ligne (pour lespacement entre les lignes) element_rect() : pour les fonds et les cadres, PARAMÈTRE VALEUR fill la couleur de remplissage colour la couleur de la bordure size la taille de la bordure linetype le type de ligne (blank, solid, dashed, dotted, dotdash, longdash, \"twodash) element_line() : pour toutes les lignes tracées, PARAMÈTRE VALEUR colour la couleur de ligne size la taille linetype le type de ligne (blank, solid, dashed, dotted, dotdash,longdash, \"twodash) lineend le type de fin de ligne (round, butt ou square) element_blank() : permet de ne rien dessiner. 9.1.6.2 Les composantes Il sagit des différents éléments modifiables dans le thème. Par exemple: Axes axis.line, axis.text.x, axis.text.y, axis.ticks, axis.title.x, axis.title.y, Légende legend.background, legend.key, legend.text, legend.title, Fond de graphe panel.background, panel.border, panel.grid.major, panel.grid.minor, etc 9.1.6.3 Quelques exemples Changer le fond du graphique panel_background() sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) + theme(panel.background = element_rect(fill = &quot;Lavender&quot;, colour = &quot;black&quot;)) Changer lapparence du quadrillage : panel_background() sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) + theme(panel.grid.major = element_line(colour = &quot;gray&quot;, size = 0.5, linetype = &quot;dashed&quot;)) Changer lapparence des étiquettes des axes : axis_xxx() sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) + theme( axis.text.x = element_text(colour = &quot;blue&quot;, angle = 45), axis.title = element_text(face = &quot;bold&quot;, colour = &quot;orange&quot;) ) Certains changements de paramètres ne nécessitent pas lutilisation de fonctions element_(). Par exemple, pour changer la position de la légende : legend.xxx() sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) + theme(legend.position = &quot;left&quot;, legend.title = element_blank()) 9.1.6.4 Modifier le thème par défaut. La fonction theme_set() vous permet de définir un thème par défaut pour lensemble de vos graphiques. theme_set(theme_dark()) sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) 9.1.6.5 Créer son propre thème Un thème est une fonction R qui va prendre en paramètre des éléments que vous souhaitez pouvoir faire varier et fixer des éléments que vous souhaitez avoir comme rendu par défaut. Créons ici un thème avec un fond vert pour le ministère de la transition écologique et solidaire. On rajoute un paramètre pour la taille de la police du titre du graphique. theme_mtes &lt;- function(taille_police = 14) { theme_bw() + theme( plot.title = element_text(color = &quot;white&quot;, size = taille_police, face = &quot;bold&quot;), text = element_text(color = &quot;white&quot;), axis.text = element_text(color = &quot;white&quot;), panel.background = element_rect(fill = &quot;lightgreen&quot;, colour = &quot;lightgreen&quot;), plot.background = element_rect(fill = &quot;#006400&quot;, colour = &quot;lightgreen&quot;), legend.background = element_rect(fill = &quot;lightgreen&quot;, colour = &quot;lightgreen&quot;), legend.key = element_blank() ) } sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) + theme_mtes() 9.1.7 Les scales Les fonctions scales() permettent globalement de paramétrer les éléments rentrés dans laesthétic : Si je veux un gradient de couleurs fonction dune variable continue : quelle palette de couleurs je choisie, comment je cale mon dégradé en fonction de cette variable continue ? Si je met une variable continue en ordonnée, comment je définis le minimum et maximum de cette axe, sa position, les valeurs que jaffiche sur léchelle Lensemble des scales possibles peuvent se décrire sous la forme suivante: scale_xx_yy() ou xx peut être un des paramètres de laesthétic : xx description alpha transparence color couleur des lignes ou des points fill couleurs des aires linetype type de ligne (continue,pointillée,) shape forme des points size aire des points x variable de laxe x y variable de laxe y Et yy un type de paramétrage : yy description continuous gérer les variables continue discrete gérer les variables discrètes date gérer une variable au format date reverse inverser laxe log convertire léchelle dune variable continue en échelle logarithmique log10 convertire léchelle dune variable continue en échelle logarithmique décimale viridis utiliser une palette de couleur viridis brewer utiliser une palette de couleur brewer (variable discrète) distiller utiliser une palette de couleur brewer (variable continue) gradient utiliser un gradient de 2 couleurs gradient2 utiliser un gradient divergent de 3 couleurs sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) + scale_color_brewer(type = &quot;qual&quot;) Par exemple on peut exploiter une fonction scale pour définir une échelle logarithimique sur un axe. sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) + scale_color_brewer(type = &quot;qual&quot;) + scale_x_log10() + scale_y_log10() 9.1.7.1 Formatage spécifique Transformation en pourcentage; scale_y_continuous(labels = scales::percent) Ajout du séparateur des milliers; scale_y_continuous(labels = function(x) format(x, big.mark = &quot; &quot;, scientific = FALSE)) Ajout du symbole ; scale_y_continuous(labels = function(x) paste(x, &quot; &quot;)) 9.1.8 La mise en page de plusieurs graphiques Le package cowplot permet la combinaison de plusieurs graphiques. Il est composé de plusieurs fonctions. le fonction plot_grid() qui permet de disposer n graphes sur i colonnes et j lignes gg1 &lt;- sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot() + geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr, color = continent), alpha = 0.5, size = 1.9 ) + labs( title = &quot;Mortalité maternelle en fonction du PIB par habitant&quot;, subtitle = &quot;En 2015&quot;, x = &quot;PIB par habitant&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;, caption = &quot;Source : ODD / ONU&quot; ) + scale_x_log10() + scale_y_log10() + theme(axis.title = element_text(size = 9)) gg2 &lt;- sdg_indicators %&gt;% filter(timeperiod ==2015) %&gt;% ggplot()+ geom_density(aes(x=gdp_per_cap))+ scale_x_log10() plot_grid(gg1, gg2, ncol = 1, nrow = 2) la fonction draw_plot() associée à ggdraw() qui permet de disposer les graphiques à des places spécifiques. ggdraw() initialise le graphique gg3 &lt;- sdg_indicators %&gt;% filter(timeperiod == 2015) %&gt;% ggplot() + geom_bar(aes(x = continent, fill = continent)) + theme( axis.title.x = element_blank(), axis.text.x = element_blank() ) ggdraw() + draw_plot(gg1, x = 0, y = .5, width = 1, height = .5) + draw_plot(gg2, x = 0, y = 0, width = .3, height = .5) + draw_plot(gg3, x = 0.3, y = 0, width = 0.7, height = .5) 9.1.9 Les facettes Lorsque lon veut pouvoir réaliser un graphique pour plusieurs sous-ensembles, les facettes sont alors très utiles. On va ici lillustrer avec la réalisation du même graphique ci-dessus mais pour plusieurs années différentes. sdg_indicators %&gt;% filter(timeperiod %in% c(2000, 2005, 2010, 2015), geoareaname %in% c(&quot;France&quot;,&quot;Canada&quot;,&quot;Burkina Faso&quot;,&quot;China&quot;,&quot;Australia&quot;)) %&gt;% ggplot() + geom_bar(aes(x = geoareaname, weight = sh_sta_mmr, fill = continent)) + theme_minimal() + scale_fill_viridis_d() + coord_flip() + scale_y_log10()+ labs( title = &quot;Mortalité maternelle sur quelques pays&quot;, subtitle = &quot;En 2015&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances), échelle logarithmique&quot;, x = &quot;Pays&quot;, fill = &quot;Pays&quot; ) + theme(legend.position = &quot;none&quot;) + facet_wrap(~timeperiod) Lexemple pris ici scinde notre table en fonction dune seule variable, mais on peut le faire sur plusieurs variables également. On peut choisir avec facet_wrap() : le nombre de colonnes ou de ligne sur lesquel on veut voir safficher le graphique si on veut fixer léchelle de lun ou lautre des axes ou les deux sdg_indicators %&gt;% filter(timeperiod %in% c(2000, 2005, 2010, 2015), geoareaname %in% c(&quot;France&quot;,&quot;Canada&quot;,&quot;Burkina Faso&quot;,&quot;China&quot;,&quot;Australia&quot;)) %&gt;% ggplot() + geom_bar(aes(x = geoareaname, weight = sh_sta_mmr, fill = continent)) + theme_minimal() + scale_fill_viridis_d() + coord_flip() + scale_y_log10()+ labs( title = &quot;Mortalité maternelle sur quelques pays&quot;, subtitle = &quot;En 2015&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances), échelle logarithmique&quot;, x = &quot;Pays&quot;, fill = &quot;Pays&quot; ) + theme(legend.position = &quot;none&quot;) + facet_wrap(~timeperiod, ncol = 4) 9.1.10 Exporter un graphique ggplot contient une fonction ggsave() qui permet dexporter nos graphiques au format image dans les formats suivants : eps, ps, tex (pictex), pdf, jpeg, tiff, png, bmp, svg or wmf p &lt;- sdg_indicators %&gt;% filter(timeperiod %in% c(2000, 2005, 2010, 2015), geoareaname %in% c(&quot;France&quot;,&quot;Canada&quot;,&quot;Burkina Faso&quot;,&quot;China&quot;,&quot;Australia&quot;)) %&gt;% ggplot() + geom_bar(aes(x = geoareaname, weight = sh_sta_mmr, fill = continent)) + theme_minimal() + scale_fill_viridis_d() + coord_flip() + scale_y_log10()+ labs( title = &quot;Mortalité maternelle sur quelques pays&quot;, subtitle = &quot;En 2015&quot;, y = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances), échelle logarithmique&quot;, x = &quot;Pays&quot;, fill = &quot;Pays&quot; ) + theme(legend.position = &quot;none&quot;) + facet_wrap(~timeperiod, ncol = 4) ggsave(&quot;figures/Mortalité maternelle sur quelques pays du globe.svg&quot;, p, width = 12, height = 5) 9.2 Faire des cartes avec ggplot2 9.2.1 Les cartes choroplèthe ggplot2 intègre une fonction geom permettant lutilisation de données géomatrique : geom_sf() Celle ci doit se coupler avec la fonction coord_sf() qui permet de sassurer en cas de superposition de couches que celles-ci utiliseront bien le même crs en spécifiant le datum. coord_sf() permet également de zoomer sur la carte en spécifiant les bornes x et y de la carte, ou également de définir les labels des axes. Le premier exemple que nous allons pouvoir voir, cest une carte choroplèthe. Pour cela, préalablement, nous allons intégrer à nos données un fond de carte : le spatial dataframe World présent dans le package tmap data(&quot;World&quot;) sdg_indicators_sf &lt;- World %&gt;% left_join(sdg_indicators) map_sdg_indicators &lt;- sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% ggplot() + geom_sf(aes(fill = log(sh_sta_mmr)),color=&quot;white&quot;,size=.2)+ scale_fill_viridis_c()+ theme_minimal()+ theme(panel.background = element_rect(fill = &quot;light blue&quot;)) map_sdg_indicators On peut exploiter de la même façon les différentes fonctions vues précédement. Par exemple avec un peu de thème et de facet. sdg_indicators_sf %&gt;% filter(timeperiod %in% c(&quot;2000&quot;,&quot;2005&quot;,&quot;2010&quot;,&quot;2015&quot;)) %&gt;% ggplot() + geom_sf(aes(fill = log(sh_sta_mmr)),color=&quot;white&quot;,size=.2)+ scale_fill_viridis_c( option = &quot;magma&quot;, direction = 1, breaks = c(0, 1, 2, 3, 4, 5, 6, 7))+ guides( colour = F, order = 0, fill = guide_legend( direction = &quot;horizontal&quot;, keyheight = unit(2, units = &quot;mm&quot;), keywidth = unit(20, units = &quot;mm&quot;), order = 1, title.position = &quot;top&quot;, title.hjust = 0.5, nrow = 1, label.position = &quot;bottom&quot;, label.hjust = 1 ) ) + theme_minimal()+ theme(legend.position = &quot;bottom&quot;, panel.background = element_rect(fill = &quot;light blue&quot;))+ labs(fill = &quot;Taux de mortalité infantile (échelle logarithmique)&quot;) + facet_wrap(~timeperiod, drop = T) 9.2.2 Les cartes à ronds proportionnels ggplot ne peut attribuer par défaut un rond proportionnel à un polygone. Pour travailler sur des ronds proportionnels, il faut dabord créer le centroid de nos zones et ensuite tracer un rond proportionnel avec geom_sf(). World_centroid &lt;- st_centroid(World, of_largest_polygon = T) sdg_indicators_sf_centroid &lt;- World_centroid %&gt;% left_join(sdg_indicators) map_sdg_indicators_centroid &lt;- sdg_indicators_sf_centroid %&gt;% filter(timeperiod == &quot;2015&quot;,!is.na(sh_sta_mmr)) %&gt;% ggplot() + geom_sf(data = World, fill = &quot;white&quot;) + geom_sf(aes(color = sh_sta_mmr, size = sh_sta_mmr))+ theme_minimal()+ theme(panel.background = element_rect(fill = &quot;light blue&quot;)) map_sdg_indicators_centroid 9.2.3 Ajouter une barre déchelle et la flèche du nord Le package ggspatial permet denrichir simplement nos cartes ggplot2 avec une barre déchelle et la flèche du nord. Les deux fonctions qui permettent cela sont annotation_scale() et annotation_north_arrow(). Lutilisation de ces fonctions nécessitent un système de coordonnées géographiques. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% st_transform(crs = 4326) %&gt;% ggplot() + geom_sf(aes(fill = log(sh_sta_mmr)), color = &quot;white&quot;, size = .2) + coord_sf(crs = 4326) + scale_fill_viridis_c() + theme_minimal() + theme(panel.background = element_rect(fill = &quot;light blue&quot;)) + annotation_scale(location = &quot;br&quot;, line_width = .5) + annotation_north_arrow(location = &quot;bl&quot;, height = unit(0.7, &quot;cm&quot;), width = unit(0.7, &quot;cm&quot;)) 9.2.4 Mettre plusieurs cartes côte à côte On peut a partir dune même carte vouloir réaliser un zoom sur une sous partie de celle-ci. coord_sf() va nous permettre de zoomer sur une carte, et cow_plot() va nous permettre dafficher nos deux cartes côte à côte. Pour zoomer sur une carte,coord_sf() va avoir besoin des coordonnées x et y du cadre sur lequel on veut zoomer. Le plus simple pour cela est de filtrer préalablement notre spatial dataframe et de récupérer la bbox de celle-ci. Filtrons par exemple sur le continent africain. bbox_africa &lt;- World %&gt;% filter(continent==&quot;Africa&quot;) %&gt;% st_bbox() On peut ensuite réaliser une carte zoomée sur lAfrique. map_sdg_indicators_africa &lt;- sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% ggplot() + geom_sf(aes(fill = log(sh_sta_mmr)), color = &quot;white&quot;, size = .2) + coord_sf(xlim = c(bbox_africa[1],bbox_africa[3]), ylim = c(bbox_africa[2],bbox_africa[4]) ) + scale_fill_viridis_c() + theme_minimal() + theme(legend.position = &quot;right&quot;, panel.background = element_rect(fill = &quot;light blue&quot;)) On peut utiliser ensuite plot_grid() pour afficher nos cartes côte à côte. Il faut jouer sur les largeurs relatives pour que les deux cartes sagencent bien. map_sdg_indicators_compo &lt;- map_sdg_indicators + theme_void()+ theme(panel.background = element_rect(fill = &quot;light blue&quot;),legend.position = &quot;none&quot;) plot_grid(map_sdg_indicators_compo,map_sdg_indicators_africa,rel_widths = c(1.7, 1)) "],["créer-des-cartes-avec-tmap.html", "Chapitre 10 Créer des cartes avec tmap 10.1 tm_shape 10.2 Exemple de carte choroplèthe 10.3 Exemple de carte à ronds proportionnels 10.4 Discretisation 10.5 Exemples de cartes avec facet 10.6 gestion des palettes 10.7 La mise en page 10.8 Assembler plusieurs cartes 10.9 tmap pour le web 10.10 Export dune carte", " Chapitre 10 Créer des cartes avec tmap tmap est un package dédié à la réalisation de cartes sous R. La syntaxe est très proche de ggplot, avec lopérateur + pour enchainer les options. Léquivalent des geom_xx() dans tmap sont les fonctions suivantes : tm_lines() : afficher des lignes tm_polygons() : afficher des polygones tm_raster() : afficher un raster tm_bubbles() : afficher des ronds proportionnels tm_markers() : afficher des marqueurs tm_text() : afficher du texte Les différences avec ggplot2 : Les variables sappellent dans des cotes \"\" ; Le facetting peut se faire sur un format de données large (une carte par colonne et non une carte par modalité dune variable) ; Les fonctions tm_xx() incluent la définition des classes (nombre de classe, définition des classes et des palettes) sans passer par une fonction scale() dont léquivalent nexiste pas. La mise en page se définit avec la fonction tm_layout(), la légende avec tm_legend() Dans ce chapitre nous allons utiliser les packages suivants library(tmap) library(sf) library(tidyverse) #remotes::install_github(&quot;MaelTheuliere/variousdata&quot;) library(variousdata) data(&quot;World&quot;) 10.1 tm_shape Pour charger une donnée géométrique, il faut utiliser la fonction tm_shape(). tm_shape() permet de fixer plusieurs options de base de notre carte : la projection, la bbox, un facteur de simplification mercator &lt;- tm_shape(World, projection = st_crs(3395)) + tm_polygons() + tm_layout(&quot;Le monde en projection Mercator&quot;, inner.margins=c(0,0,.1,0), title.size=.8) robin &lt;- tm_shape(World, projection = &quot;+proj=robin +lon_0=0 +x_0=0 +y_0=0&quot;) + tm_polygons() + tm_layout( &quot;Le monde en projection Robinson&quot;, inner.margins=c(0,0,.1,0), title.size=.8) 10.2 Exemple de carte choroplèthe La fonction tm_polygons() permet de faire des cartes choroplèthe. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;,textNA=&quot;Valeur manquante&quot;)+ tm_borders(&quot;white&quot;, lwd = .5) 10.3 Exemple de carte à ronds proportionnels La fonction tm_bubble() permet de faire des cartes à ronds proportionnels. Lutilisation de tm_polygons() permet sans lui spécifier de paramètre dafficher les frontière des pays avec une couleur de remplissage par défaut. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons()+ tm_bubbles(size=&quot;sh_sta_mmr&quot;,col=&quot;sh_sta_mmr&quot;,textNA = &quot;Valeur manquante&quot;) 10.4 Discretisation Pour définir comment notre variable continue va être discrétisée, deux méthodes : discrétiser à la main et indiquer les valeurs limites dans loption breaks de notre tm_xx utiliser loption style des tm_xx qui permettent de choisir un algorithme de discrétisation. La méthode de jenks par exemple permet de maximiser la variance interclasse. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;, textNA=&quot;Valeur manquante&quot;, style=&quot;jenks&quot;) Loption n= permet dimposer un nombre de classes à la méthode utilisée. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;, textNA = &quot;Valeur manquante&quot;, style = &quot;jenks&quot;,n = 3) 10.5 Exemples de cartes avec facet tm_facets() permet de réaliser des cartes à facette avec la même logique que celle de ggplot2. sdg_indicators_sf %&gt;% filter(timeperiod %in% c(&quot;2000&quot;, &quot;2005&quot;, &quot;2010&quot;, &quot;2015&quot;)) %&gt;% tm_shape() + tm_polygons(&quot;sh_sta_mmr&quot;, textNA = &quot;Valeur manquante&quot;, style = &quot;jenks&quot;) + tm_facets(&quot;timeperiod&quot;) 10.6 gestion des palettes La fonction tmaptools::palette_explorer() permet daccéder à une interface très simple de définition dune palette de couleur à partir des palette brewer. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;, textNA = &quot;Valeur manquante&quot;, style = &quot;jenks&quot;,palette = get_brewer_pal(&quot;OrRd&quot;, n = 5, contrast = c(0.2, 1)), plot = F) On peut également utiliser nimporte quelle palette, par exemple la pelette viridis, mais sans linterface proposée par palette_explorer() : sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;, textNA = &quot;Valeur manquante&quot;, style = &quot;jenks&quot;,palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;)) 10.7 La mise en page tm_layout() permet de controler les polices, la légende, les marges, les couleurs. loption design.mode=T permet de voir visuellement les marges,la position de la légende. Le titre de la légende ne se définit pas dans tm_layout() mais dans tm_polygons(). Loption title de ces fonctions est léquivalent dun libellé de la variable mise dans laesthetic. On peut rajouter une barre déchelle et la flèche du nord avec tm_scale_bar() et tm_compass(). sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;,textNA = &quot;Valeur manquante&quot;, style = &quot;jenks&quot;,palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;), title = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;)+ tm_layout(main.title = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances) dans le monde&quot;, main.title.size = 1.2, bg.color = &quot;skyblue&quot;, legend.position = c(&quot;left&quot;,&quot;bottom&quot;), legend.bg.color = &quot;white&quot;, legend.bg.alpha = .4, legend.outside = F, main.title.position = &quot;center&quot;, frame = FALSE)+ tm_scale_bar(position = c(&quot;center&quot;,&quot;bottom&quot;))+ tm_compass(position = c(&quot;right&quot;,&quot;top&quot;)) Avec les cartes en ronds proportionnels, on peut spécifier un titre pour la couleur et la taille du rond. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons()+ tm_bubbles(size=&quot;sh_sta_mmr&quot;,col=&quot;sh_sta_mmr&quot;,style=&quot;jenks&quot;, palette=viridis(5, alpha = 1, begin = 0, end = 1, direction = 1, option = &quot;D&quot;), title.col=&quot;&quot;, title.size=&quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;)+ tm_layout(main.title=&quot;Taux de mortalité de la mère \\n(pour 100 000 naissances) dans le monde&quot;, main.title.size=1.2, outer.margins=c(0,0,0,0), legend.position=c(&quot;left&quot;,&quot;bottom&quot;), legend.outside = F, main.title.position = &quot;center&quot;, inner.margins = c(0, 0, 0, 0), frame = FALSE)+ tm_scale_bar(position = c(&quot;center&quot;,&quot;bottom&quot;))+ tm_compass(position = c(&quot;right&quot;,&quot;top&quot;)) 10.8 Assembler plusieurs cartes tmap_arrange() permet dassembler plusieurs cartes ensemble. La limite de tmap_arrange() : la fonction ne permet pas de fixer un vecteur de largeur différent pour les cartes. A utiliser donc sur des cas qui peuvent convenir à cette contrainte. tmap_sdg_indicators &lt;- sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;, style = &quot;jenks&quot;,palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;))+ tm_layout() tmap_sdg_indicators_africa &lt;- sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape(bbox = bbox_africa)+ tm_polygons(&quot;sh_sta_mmr&quot;, style = &quot;jenks&quot;,palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;))+ tm_layout(legend.show = F) tmap_arrange(tmap_sdg_indicators,tmap_sdg_indicators_africa,nrow = 1) 10.9 tmap pour le web tmap permet simplement de convertir une carte image en carte interactive. Pour cela il faut changer le mode daffichage de la carte avec tmap_mode() tmap_mode(&quot;view&quot;) sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;)+ tm_borders(&quot;white&quot;, lwd = .5) 10.10 Export dune carte La fonction tmap_save() permet dexporter une carte tmap. Suivant le tmap_mode() activé, lexport peut se faire en fichier image ou en fichier html. carte &lt;- sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape() + tm_polygons() + tm_bubbles( size = &quot;sh_sta_mmr&quot;, col = &quot;sh_sta_mmr&quot;, palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;), title.col = &quot;&quot;, title.size = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot; ) + tm_layout( main.title = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances) dans le monde&quot;, main.title.size = 1.2, outer.margins = c(0, 0, 0, 0), legend.position = c(&quot;left&quot;, &quot;bottom&quot;), legend.outside = F, main.title.position = &quot;center&quot;, inner.margins = c(0, 0, 0, 0) ) tmap_mode(&quot;plot&quot;) tmap_save(carte, filename = &quot;Taux de mortalité de la mère dans le monde.png&quot;) tmap_mode(&quot;view&quot;) tmap_save(carte, filename = &quot;Taux de mortalité de la mère dans le monde.html&quot;)``` "],["créer-des-cartogrammes.html", "Chapitre 11 Créer des cartogrammes 11.1 Cartogramme daire contigue 11.2 Cartogramme daire non contigue 11.3 Cartogramme de Dorling", " Chapitre 11 Créer des cartogrammes Un cartogramme est une carte pour laquelle une variable continue, remplace la surface des territoires représentés. La géométrie de lespace de la carte est déformée afin de se conformer aux informations relatives à cette variable. Les fonctions du package cartogramm permettent de réaliser lopération de déformation attendue. La sortie de ces fonctions est un spatial dataframe avec une nouvelle géométrie. On peut ensuite utiliser cette nouvelle géométrie pour la visualiser avec tout package de cartographie. Dans ce chapitre nous allons utiliser les packages suivants. library(cartogram) library(tmap) library(ggplot2) #remotes::install_github(&quot;MaelTheuliere/variousdata&quot;) library(variousdata) data(&quot;World&quot;) 11.1 Cartogramme daire contigue Définition de la couche à partir de la variable dune table. Ici en loccurence le taux de mortalité de la mère à la naissance. La fonction cartogram_cont() permet de définir la déformation attendue. mmr_cont &lt;- cartogram_cont(sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;), &quot;sh_sta_mmr&quot;) On peut ensuite utiliser le package que lon souhaite pour cartographier cette couche. avec tmap mmr_cont %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;,palette=viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;), title=&quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;)+ tm_layout(main.title=&quot;Taux de mortalité de la mère \\n(pour 100 000 naissances) dans le monde&quot;, main.title.size=1.2, bg.color = &quot;skyblue&quot;, legend.position=c(&quot;left&quot;,&quot;bottom&quot;), legend.outside = F, main.title.position = &quot;center&quot;, frame = FALSE) avec ggplot2 mmr_cont %&gt;% ggplot() + geom_sf(aes(fill = log(sh_sta_mmr)),color=&quot;white&quot;,size=.2)+ scale_fill_viridis_c( option = &quot;magma&quot;, direction = 1, breaks = c(0, 1, 2, 3, 4, 5, 6, 7))+ guides( colour = F, order = 0, fill = guide_legend( direction = &quot;horizontal&quot;, keyheight = unit(2, units = &quot;mm&quot;), keywidth = unit(20, units = &quot;mm&quot;), order = 1, title.position = &quot;top&quot;, title.hjust = 0.5, nrow = 1, label.position = &quot;bottom&quot;, label.hjust = 1 ) ) + theme_minimal()+ theme(legend.position = &quot;bottom&quot;, panel.background = element_rect(fill = &quot;light blue&quot;))+ labs(fill = &quot;Taux de mortalité infantile (échelle logarithmique)&quot;) 11.2 Cartogramme daire non contigue La fonction cartogram_ncont() permet de définir la déformation attendue. On va ici réaliser le cartogramme sur le log de la mortalité des mères à la naissance. mmr_ncont &lt;- cartogram_ncont(sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;,continent == &quot;Africa&quot;) %&gt;% mutate(log_sh_sta_mmr = log(sh_sta_mmr)), &quot;log_sh_sta_mmr&quot;) tm_shape(World)+ tm_polygons()+ tm_shape(mmr_ncont, is.master = T)+ tm_polygons(&quot;log_sh_sta_mmr&quot;,palette=viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;), title=&quot;Taux de mortalité de la mère \\n(pour 100 000 naissances) en Afrique \\néchelle logarithmique&quot;)+ tm_layout(main.title=&quot;Taux de mortalité de la mère \\n en Afrique&quot;, main.title.size=1, bg.color = &quot;skyblue&quot;, legend.position=c(&quot;left&quot;,&quot;bottom&quot;), legend.outside = T, main.title.position = &quot;center&quot;, frame = F) 11.3 Cartogramme de Dorling Le cartogramme de Dorling est une représentation spatiale qui vise à remplaer les polygones par des cercles proportionnels à une variable données respectant au maximum la position spatiale des polygones. La fonction cartogram_dorling() permet de définir la géométrie attendue. On va ici réaliser un cartogramme de dorling sur le PIB par habitant en 2015. gdp_dorling &lt;- cartogram_dorling(sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;,!is.na(gdp_per_cap)),&quot;gdp_per_cap&quot;) tm_shape(World) + tm_borders() + tm_shape(gdp_dorling) + tm_polygons(&quot;continent&quot;) + tm_layout(frame = FALSE) + tm_layout(main.title=&quot;PIB par habitant dans le monde&quot;, main.title.size=1, bg.color = &quot;skyblue&quot;, legend.position=c(&quot;left&quot;,&quot;bottom&quot;), legend.outside = F, main.title.position = &quot;center&quot;, frame = T) "],["créer-des-cartes-pour-le-web.html", "Chapitre 12 Créer des cartes pour le web 12.1 Les cartes Leaflet 12.2 Exporter une sortie html", " Chapitre 12 Créer des cartes pour le web 12.1 Les cartes Leaflet leaflet est une bibliothèque javascript de cartographie en ligne. R permet de produire des cartes en exploitant cette bibliothèque. La limitation de leaflet est quil ne permet de visualiser que des données en projection WGS84. Dans ce chapitre, nous utiliserons les packages suivants library(leaflet) library(sf) library(tidyverse) #remotes::install_github(&quot;MaelTheuliere/variousdata&quot;) library(variousdata) 12.1.1 Carte choroplète Ci-dessous un exemple avancé de carte choroplète avec leaflet. Définition des données de départ sdg_indicators_2015_sf &lt;- sdg_indicators_sf %&gt;% filter(timeperiod ==2015) Transformation de la projection car leaflet ne connait que le WGS 84 sdg_indicators_2015_sf&lt;-st_transform(sdg_indicators_2015_sf,crs=(&quot;+proj=longlat +datum=WGS84 +no_defs&quot;)) Discrétisation de la variable dintérêt bins &lt;-quantile(sdg_indicators_2015_sf$sh_sta_mmr, na.rm=T) Création dune palette de couleurs associée leaflet intègre une fonction colorBin() qui permet dassocier à un vecteur de valeurs numériques un vecteur de couleurs en fonction dune palette et dun vecteur de bornes. pal &lt;- colorBin(&quot;YlOrRd&quot;, domain = sdg_indicators_2015_sf$sh_sta_mmr, bins = bins) Création dun label ad-hoc à afficher en surbrillance au passage de la souris sur la carte. labels &lt;- sprintf( &quot;&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g décès pour 100 000 naissance en 2015&quot;, sdg_indicators_2015_sf$geoareaname, sdg_indicators_2015_sf$sh_sta_mmr ) %&gt;% lapply(htmltools::HTML) Réalisation de la carte La fonction addPolygons() permet de créer la carte choroplète. La fonction addProviderTiles() permet de rajouter un fond cartographique parmis les couches fournies par leaflet. leaflet(sdg_indicators_2015_sf) %&gt;% addProviderTiles(providers$CartoDB.Positron) %&gt;% addPolygons(data=sdg_indicators_2015_sf, fillColor=~pal(sh_sta_mmr), weight = 2, opacity = 1, color = &quot;white&quot;, dashArray = &quot;3&quot;, fillOpacity = 0.7, highlight = highlightOptions( weight = 5, color = &quot;#666&quot;, dashArray = &quot;&quot;, fillOpacity = 0.7, bringToFront = TRUE), label = labels, labelOptions = labelOptions( style = list(&quot;font-weight&quot; = &quot;normal&quot;, padding = &quot;3px 8px&quot;), textsize = &quot;15px&quot;, direction = &quot;auto&quot;)) 12.1.2 Carte à ronds proportionnels Pour réaliser des ronds proportionnels, il va falloir comme pour ggplot2 partir des centroides de nos polygones. Création de la table en entrée sdg_indicators_2015_sf_centroid &lt;- sdg_indicators_sf_centroid %&gt;% filter(timeperiod ==2015) Transformation de la projection car leaflet ne connait que le WGS 84 sdg_indicators_2015_sf_centroid &lt;- st_transform(sdg_indicators_2015_sf_centroid,crs=(&quot;+proj=longlat +datum=WGS84 +no_defs&quot;)) Discrétisation de la variable dintérêt bins &lt;-quantile(sdg_indicators_2015_sf_centroid$sh_sta_mmr,na.rm=T) Création dune palette de couleurs associée pal &lt;- colorBin(&quot;YlOrRd&quot;, domain = sdg_indicators_2015_sf_centroid$sh_sta_mmr, bins = bins) Création dun label ad-hoc à afficher en surbrillance au passage de la souris sur la carte. labels &lt;- sprintf( &quot;&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g décès pour 100 000 naissance en 2015&quot;, sdg_indicators_2015_sf_centroid$geoareaname, sdg_indicators_2015_sf_centroid$sh_sta_mmr ) %&gt;% lapply(htmltools::HTML) Création de la carte carte_rond_proportionnel&lt;-leaflet(sdg_indicators_2015_sf_centroid) %&gt;% addProviderTiles(providers$CartoDB.Positron) %&gt;% addPolygons(data=sdg_indicators_2015_sf, fillColor = &quot;#ffffff&quot;, opacity=.2, color = &quot;white&quot;, dashArray = &quot;3&quot;, fillOpacity = 0.7 ) %&gt;% addCircles(data=sdg_indicators_2015_sf_centroid, fillColor=~pal(sh_sta_mmr), radius=~100000*log2(sh_sta_mmr), weight = 2, opacity = 1, color = &quot;white&quot;, dashArray = &quot;3&quot;, fillOpacity = 0.7, highlight = highlightOptions( weight = 5, color = &quot;#666&quot;, dashArray = &quot;&quot;, fillOpacity = 0.7, bringToFront = TRUE), label = labels, labelOptions = labelOptions( style = list(&quot;font-weight&quot; = &quot;normal&quot;, padding = &quot;3px 8px&quot;), textsize = &quot;15px&quot;, direction = &quot;auto&quot;)) %&gt;% addLegend(&quot;bottomright&quot;, pal = pal, values = ~sh_sta_mmr, title = &quot;Taux de décès des mères à la naissance&quot;, opacity = 1) carte_rond_proportionnel 12.2 Exporter une sortie html La foncion saveWidget() permet dexporter une sortie dun HTML Widget en fichier HTML. saveWidget(widget=carte_rond_proportionnel,file=&quot;Taux de décès des mères à la naissance.html&quot;) "],["a-propos-de-ce-document.html", "A propos de ce document Code source Inspiration Licence Session info", " A propos de ce document Code source Le code source de ce document se trouve à ladresse suivante : https://github.com/MaelTheuliere/rspatial Il est généré par lexcellente extension bookdown de Yihui Xie. Inspiration Ce document est largement inspiré des deux supports suivant : Geocomputation with R de Robin Lovelace, Jakub Nowosad et Jannes Muenchow Datavisualisation : produire des graphiques, des cartes et des tableaux avec R, de Murielle Lethrones et Maël THEULIERE, du parcours de formation à R du Ministère de la Transition écologique et solidaire et du Ministère de la Cohésion des territoires et des Relations avec les collectivités territoriales La feuille de style utilisée a été réalisée par Julien Barnier pour son Introduction à R et au tidyverse Licence Ce document est mise à disposition selon les termes de la Licence Creative Commons Attribution - Pas dUtilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International. Session info setting value version R version 4.0.3 (2020-10-10) os Windows 10 x64 system x86_64, mingw32 ui RStudio language (EN) collate French_France.1252 ctype French_France.1252 tz Europe/Paris date 2021-01-15 package ondiskversion source cartogram 0.2.2 CRAN (R 4.0.3) cowplot 1.1.1 CRAN (R 4.0.3) dplyr 1.0.2 CRAN (R 4.0.3) DT 0.16 CRAN (R 4.0.3) forcats 0.5.0 CRAN (R 4.0.3) ggplot2 3.3.3 CRAN (R 4.0.3) ggspatial 1.1.5 CRAN (R 4.0.3) glue 1.4.2 CRAN (R 4.0.3) htmlwidgets 1.5.3 CRAN (R 4.0.3) kableExtra 1.3.1 CRAN (R 4.0.3) knitr 1.30 CRAN (R 4.0.3) leaflet 2.0.3 CRAN (R 4.0.3) leafpop 0.0.6 CRAN (R 4.0.3) lwgeom 0.2.5 CRAN (R 4.0.3) mapview 2.9.8 Github (r-spatial/mapview@b96de52) patchwork 1.1.1 CRAN (R 4.0.3) purrr 0.3.4 CRAN (R 4.0.3) readr 1.4.0 CRAN (R 4.0.3) rmapshaper 0.4.4 CRAN (R 4.0.3) RPostgres 1.2.1 CRAN (R 4.0.3) scales 1.1.1 CRAN (R 4.0.3) sf 0.9.6 CRAN (R 4.0.3) stringr 1.4.0 CRAN (R 4.0.3) tibble 3.0.4 CRAN (R 4.0.3) tidyr 1.1.2 CRAN (R 4.0.3) tidyverse 1.3.0 CRAN (R 4.0.3) tmap 3.2 CRAN (R 4.0.3) tmaptools 3.1 CRAN (R 4.0.3) variousdata 0.0.0.9000 Github (MaelTheuliere/variousdata@532e601) viridis 0.5.1 CRAN (R 4.0.3) viridisLite 0.3.0 CRAN (R 4.0.3) "]]
